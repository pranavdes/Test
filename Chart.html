<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Meta tags for character encoding and responsive design -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Page title -->
    <title>Enhanced QA Review Analytics Dashboard</title>
    
    <!-- External library imports for Chart.js functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-datalabels/2.2.0/chartjs-plugin-datalabels.min.js"></script>
    
    <style>
        /* ===========================================
           CSS STYLING & RESPONSIVE DESIGN
           =========================================== */
        
        /* ===== BASE STYLES & RESET ===== */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            line-height: 1.6;
            color: #333;
        }
        
        /* ===== MAIN CONTAINER LAYOUT ===== */
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        /* Header styling with gradient background */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }
        
        .header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 16px;
        }
        
        /* ===== DASHBOARD GRID LAYOUT ===== */
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            padding: 20px;
            min-height: calc(100vh - 200px);
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow: hidden;
        }
        
        .sidebar {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            height: fit-content;
            max-height: 90vh;
            overflow-y: auto;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }
        
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #5a6fd8;
        }
        
        /* ===== CONTROL SECTIONS ===== */
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .control-group label {
            font-weight: 600;
            color: #555;
            font-size: 14px;
            user-select: none;
        }
        
        .control-group input, 
        .control-group select, 
        .control-group button {
            padding: 10px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }
        
        .control-group button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-group button:hover, 
        .control-group button:focus {
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            outline: none;
        }
        
        .control-group input:focus, 
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        /* ===== CHART CONTAINERS ===== */
        .chart-container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .chart-container:hover {
            box-shadow: 0 8px 30px rgba(0,0,0,0.12);
            border-color: #667eea;
        }
        
        /* Chart maximization overlay */
        .chart-maximize-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.95);
            z-index: 9999;
            padding: 20px;
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .maximize-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }
        
        .maximize-header h3 {
            font-size: 24px;
            font-weight: 300;
        }
        
        .close-maximize {
            background: #ff4757;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-maximize:hover {
            background: #ff3742;
            transform: scale(1.1);
        }
        
        .maximize-chart-wrapper {
            height: calc(100vh - 120px);
            background: white;
            border-radius: 12px;
            padding: 20px;
            position: relative;
        }
        
        /* Trend analysis container */
        .trend-container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .trend-container h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: 600;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        /* ===== DATA INPUT SECTIONS ===== */
        .data-input {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .data-input h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: 600;
        }
        
        .function-input {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 15px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .function-input:hover {
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .function-input h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }
        
        /* ===== FORM ELEMENTS ===== */
        .category-header {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            margin-bottom: 10px;
            padding: 10px;
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            border-radius: 8px;
        }
        
        .category-header-item {
            text-align: center;
            font-weight: bold;
            font-size: 13px;
            color: #333;
            padding: 6px;
            background: rgba(255,255,255,0.7);
            border-radius: 4px;
        }
        
        .year-data {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .year-label {
            font-weight: 600;
            color: #555;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .grade-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
            gap: 10px;
        }
        
        .grade-inputs input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            text-align: center;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .grade-inputs input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
            background: #f8f9ff;
        }
        
        /* ===== SIDEBAR SECTIONS ===== */
        .section-header {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin: 25px 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid #667eea;
            position: relative;
        }
        
        .section-header:first-child {
            margin-top: 0;
        }
        
        .section-header::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 30px;
            height: 2px;
            background: #764ba2;
        }
        
        /* ===== AXIS CONTROLS ===== */
        .axis-controls {
            background: rgba(33, 150, 243, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid rgba(33, 150, 243, 0.2);
        }
        
        .axis-section {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e1e5e9;
        }
        
        .axis-section:last-child {
            margin-bottom: 0;
        }
        
        .axis-section h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        
        .axis-control-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .axis-control-group:last-child {
            margin-bottom: 0;
        }
        
        .axis-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .axis-control label {
            font-size: 12px;
            font-weight: 600;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .axis-control input {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .axis-control input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        .axis-control .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        
        /* ===== TEXT STYLING CONTROLS ===== */
        .text-styling-controls {
            background: rgba(102, 126, 234, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        
        .text-style-group {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e1e5e9;
        }
        
        .text-style-group:last-child {
            margin-bottom: 0;
        }
        
        .text-style-group h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        
        .style-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        .style-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .style-control label {
            font-size: 12px;
            font-weight: 600;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .style-control input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }
        
        .style-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .style-control input[type="range"]::-webkit-slider-thumb:hover {
            background: #5a6fd8;
            transform: scale(1.1);
        }
        
        .style-control input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .style-control input[type="color"] {
            width: 50px;
            height: 35px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .style-control input[type="color"]:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }
        
        .style-control select {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .style-control select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        /* ===== TREND LINE CONTROLS ===== */
        .trendline-controls {
            background: rgba(255, 152, 0, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 152, 0, 0.2);
        }
        
        .trendline-category {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e1e5e9;
            transition: all 0.3s ease;
        }
        
        .trendline-category:hover {
            border-color: #ff9800;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.1);
        }
        
        .trendline-category:last-child {
            margin-bottom: 0;
        }
        
        .trendline-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .trendline-color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid #333;
        }
        
        .trendline-name {
            font-weight: 600;
            color: #333;
            flex: 1;
        }
        
        .trendline-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .trendline-controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        /* ===== DATA LABELS SECTION ===== */
        .data-labels-section {
            background: rgba(76, 175, 80, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid rgba(76, 175, 80, 0.2);
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            margin-top: 12px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .checkbox-item:hover {
            background: rgba(102, 126, 234, 0.05);
        }
        
        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #667eea;
            cursor: pointer;
        }
        
        .checkbox-item label {
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            user-select: none;
        }
        
        /* ===== SHADING CONTROLS ===== */
        .shading-controls {
            background: rgba(63, 81, 181, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid rgba(63, 81, 181, 0.2);
        }
        
        .shading-option {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            padding: 10px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .shading-option:hover {
            background: rgba(63, 81, 181, 0.05);
        }
        
        .shading-option input[type="radio"] {
            width: 18px;
            height: 18px;
            accent-color: #667eea;
            cursor: pointer;
        }
        
        .shading-option label {
            font-weight: 500;
            cursor: pointer;
            user-select: none;
        }
        
        .shading-preview {
            display: flex;
            gap: 12px;
            margin-top: 15px;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.7);
            border-radius: 6px;
        }
        
        .preview-box {
            width: 50px;
            height: 35px;
            border-radius: 6px;
            border: 2px solid #333;
            transition: all 0.3s ease;
        }
        
        .preview-box:hover {
            transform: scale(1.05);
        }
        
        /* ===== SPACING CONTROLS ===== */
        .spacing-controls {
            background: rgba(255, 193, 7, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 193, 7, 0.2);
        }
        
        .spacing-control {
            margin-bottom: 15px;
        }
        
        .spacing-control:last-child {
            margin-bottom: 0;
        }
        
        .spacing-control label {
            display: block;
            font-weight: 600;
            color: #555;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .value-display {
            font-weight: bold;
            color: #667eea;
        }
        
        .spacing-description {
            font-size: 12px;
            color: #666;
            margin-top: 6px;
            font-style: italic;
            line-height: 1.4;
        }
        
        /* ===== ITEM LISTS ===== */
        .add-item {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: end;
            flex-wrap: wrap;
        }
        
        .add-item input, 
        .add-item select {
            flex: 1;
            min-width: 120px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .add-item input:focus, 
        .add-item select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        .add-item button {
            padding: 10px 15px;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            white-space: nowrap;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .add-item button:hover, 
        .add-item button:focus {
            background: linear-gradient(135deg, #45a049 0%, #3d8b40 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
            outline: none;
        }
        
        .item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: white;
            margin-bottom: 10px;
            border-radius: 8px;
            border: 2px solid #eee;
            transition: all 0.3s ease;
        }
        
        .item:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }
        
        .item-color {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            margin-right: 12px;
            border: 2px solid #333;
            transition: all 0.3s ease;
        }
        
        .item-info {
            display: flex;
            align-items: center;
            flex: 1;
            font-weight: 500;
        }
        
        .item-name-input {
            background: transparent;
            border: none;
            font-size: 16px;
            font-weight: 500;
            color: #333;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .item-name-input:hover {
            background: rgba(102, 126, 234, 0.05);
        }
        
        .item-name-input:focus {
            outline: none;
            background: white;
            border: 2px solid #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        .year-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: white;
            margin-bottom: 10px;
            border-radius: 8px;
            border: 2px solid #eee;
            transition: all 0.3s ease;
        }
        
        .year-item:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }
        
        .year-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .year-indicator {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .previous-year {
            background: linear-gradient(135deg, #ffc107 0%, #ffb300 100%);
            color: #333;
        }
        
        .current-year {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }
        
        /* ===== BUTTONS ===== */
        .remove-button {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }
        
        .remove-button:hover, 
        .remove-button:focus {
            background: linear-gradient(135deg, #d32f2f 0%, #c62828 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
            outline: none;
        }
        
        .edit-button {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }
        
        .edit-button:hover,
        .edit-button:focus {
            background: linear-gradient(135deg, #f57c00 0%, #ef6c00 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4);
            outline: none;
        }
        
        /* ===== SORTING CONTROLS ===== */
        .sorting-controls {
            margin-bottom: 15px;
        }
        
        .sort-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 12px;
            background: white;
            border-radius: 8px;
            border: 2px solid #eee;
            transition: all 0.3s ease;
        }
        
        .sort-item:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }
        
        .sort-item span {
            flex: 1;
            font-weight: 500;
        }
        
        .sort-item button {
            padding: 6px 10px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 35px;
        }
        
        .sort-item button:hover:not(:disabled) {
            background: #f0f0f0;
            border-color: #667eea;
            color: #667eea;
        }
        
        .sort-item button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        /* ===== CHART ELEMENTS ===== */
        canvas {
            max-height: 600px;
            transition: all 0.3s ease;
        }
        
        .trend-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .trend-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .trend-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }
        
        .trend-card h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .trend-card .value {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .trend-card .change {
            font-size: 12px;
            opacity: 0.8;
        }
        
        /* ===== LEGEND ===== */
        .legend-custom {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 500;
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid transparent;
            background: rgba(255,255,255,0.9);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .legend-item:hover {
            border-color: #667eea;
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            border: 2px solid #333;
            transition: all 0.3s ease;
        }
        
        .legend-item:hover .legend-color {
            transform: scale(1.1);
        }
        
        /* ===== ACCESSIBILITY ELEMENTS ===== */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .skip-link {
            position: absolute;
            top: -50px;
            left: 10px;
            background: #667eea;
            color: white;
            padding: 10px 15px;
            text-decoration: none;
            border-radius: 6px;
            z-index: 10000;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .skip-link:focus {
            top: 10px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        /* Focus indicators for interactive elements */
        [role="region"] {
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 10px;
            transition: all 0.3s ease;
        }
        
        [role="region"]:focus {
            border-color: #667eea;
            outline: none;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }
        
        /* ===== LOADING STATES ===== */
        .loading {
            opacity: 0.6;
            pointer-events: none;
            position: relative;
        }
        
        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            margin: -15px 0 0 -15px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* ===== RESPONSIVE DESIGN ===== */
        
        /* Large Desktop Screens (1200px and up) */
        @media (min-width: 1200px) {
            .container {
                max-width: 1800px;
            }
            
            .dashboard {
                grid-template-columns: 1fr 450px;
                gap: 25px;
                padding: 25px;
            }
            
            .header h1 {
                font-size: 32px;
            }
            
            .controls {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            }
        }
        
        /* Medium Desktop Screens (992px to 1199px) */
        @media (max-width: 1199px) and (min-width: 992px) {
            .dashboard {
                grid-template-columns: 1fr 380px;
            }
            
            .controls {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            }
        }
        
        /* Tablet Landscape (768px to 991px) */
        @media (max-width: 991px) and (min-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .sidebar {
                max-height: none;
                order: -1;
            }
            
            .controls {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 12px;
            }
            
            .text-styling-controls {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 15px;
            }
            
            .trendline-controls {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 15px;
            }
            
            .trend-summary {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            }
        }
        
        /* Tablet Portrait (576px to 767px) */
        @media (max-width: 767px) and (min-width: 576px) {
            body {
                padding: 15px;
            }
            
            .container {
                border-radius: 12px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 24px;
            }
            
            .header p {
                font-size: 14px;
            }
            
            .dashboard {
                padding: 15px;
                gap: 15px;
            }
            
            .controls {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 10px;
                padding: 15px;
            }
            
            .chart-container,
            .trend-container {
                padding: 20px;
            }
            
            .sidebar {
                padding: 15px;
            }
            
            .text-styling-controls,
            .trendline-controls {
                display: block;
            }
            
            .text-style-group,
            .trendline-category {
                margin-bottom: 15px;
            }
            
            .style-controls {
                grid-template-columns: 1fr;
            }
            
            .trendline-controls-grid {
                grid-template-columns: 1fr;
            }
            
            .checkbox-group {
                grid-template-columns: 1fr;
            }
            
            .trend-summary {
                grid-template-columns: 1fr;
            }
            
            .legend-custom {
                gap: 10px;
            }
            
            .legend-item {
                font-size: 12px;
                padding: 8px 10px;
            }
        }
        
        /* Mobile Devices (up to 575px) */
        @media (max-width: 575px) {
            body {
                padding: 10px;
            }
            
            .container {
                margin: 0;
                border-radius: 8px;
                box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            }
            
            .header {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 20px;
                letter-spacing: 0.5px;
            }
            
            .header p {
                font-size: 13px;
            }
            
            .dashboard {
                padding: 10px;
                gap: 10px;
            }
            
            .controls {
                grid-template-columns: 1fr;
                gap: 8px;
                padding: 12px;
            }
            
            .control-group {
                gap: 6px;
            }
            
            .control-group input,
            .control-group select,
            .control-group button {
                padding: 8px 10px;
                font-size: 13px;
            }
            
            .chart-container,
            .trend-container,
            .data-input {
                padding: 15px;
            }
            
            .sidebar {
                padding: 12px;
            }
            
            .section-header {
                font-size: 16px;
                margin: 20px 0 12px 0;
            }
            
            .text-style-group,
            .trendline-category,
            .axis-section {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .style-control input,
            .style-control select,
            .axis-control input {
                padding: 6px;
                font-size: 12px;
            }
            
            .add-item {
                flex-direction: column;
                gap: 8px;
            }
            
            .add-item input,
            .add-item select,
            .add-item button {
                width: 100%;
                min-width: auto;
            }
            
            .item,
            .year-item,
            .sort-item {
                padding: 10px;
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            .item-info {
                justify-content: center;
            }
            
            .year-controls,
            .sort-item > div:last-child {
                justify-content: center;
            }
            
            .grade-inputs {
                grid-template-columns: 1fr;
            }
            
            .category-header {
                grid-template-columns: 1fr;
            }
            
            .legend-custom {
                flex-direction: column;
                align-items: center;
                gap: 8px;
            }
            
            .legend-item {
                font-size: 11px;
                padding: 6px 8px;
                width: 100%;
                justify-content: center;
            }
            
            .trend-card {
                padding: 15px;
            }
            
            .trend-card .value {
                font-size: 24px;
            }
            
            .maximize-chart-wrapper {
                padding: 10px;
            }
            
            .close-maximize {
                width: 35px;
                height: 35px;
                font-size: 20px;
            }
        }
        
        /* ===== HIGH CONTRAST MODE ===== */
        @media (prefers-high-contrast: active) {
            .container,
            .function-input,
            .item,
            .year-item,
            .sort-item,
            .chart-container,
            .trend-container {
                border-width: 3px;
                border-color: CanvasText;
            }
            
            .control-group input,
            .control-group select,
            .style-control input,
            .style-control select,
            .axis-control input {
                border-width: 2px;
                border-color: CanvasText;
            }
            
            .legend-color,
            .item-color,
            .preview-box {
                border-width: 3px;
                border-color: CanvasText;
            }
        }
        
        /* ===== REDUCED MOTION ===== */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .chart-maximize-overlay {
                animation: none;
            }
            
            .loading::after {
                animation: none;
            }
        }
        
        /* ===== PRINT STYLES ===== */
        @media print {
            body {
                background: white;
                padding: 0;
            }
            
            .container {
                box-shadow: none;
                border: 1px solid #000;
            }
            
            .sidebar,
            .controls,
            .skip-link,
            .chart-maximize-overlay {
                display: none !important;
            }
            
            .dashboard {
                grid-template-columns: 1fr;
                padding: 20px;
            }
            
            .chart-container,
            .trend-container {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #000;
            }
            
            .header {
                background: white !important;
                color: black !important;
                border-bottom: 2px solid #000;
            }
            
            canvas {
                max-height: none;
            }
        }
        
        /* ===== DARK MODE SUPPORT ===== */
        @media (prefers-color-scheme: dark) {
            body {
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                color: #e0e0e0;
            }
            
            .container {
                background: #2d3748;
                color: #e0e0e0;
            }
            
            .sidebar,
            .controls,
            .data-input {
                background: #4a5568;
            }
            
            .chart-container,
            .trend-container,
            .function-input,
            .text-style-group,
            .trendline-category,
            .axis-section,
            .item,
            .year-item,
            .sort-item {
                background: #2d3748;
                border-color: #4a5568;
            }
            
            .control-group input,
            .control-group select,
            .style-control input,
            .style-control select,
            .axis-control input,
            .add-item input,
            .add-item select,
            .grade-inputs input,
            .item-name-input {
                background: #4a5568;
                border-color: #718096;
                color: #e0e0e0;
            }
            
            .category-header {
                background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            }
            
            .category-header-item {
                background: rgba(255,255,255,0.1);
                color: #e0e0e0;
            }
            
            .year-data {
                background: rgba(102, 126, 234, 0.1);
            }
            
            .section-header {
                color: #e0e0e0;
            }
            
            .legend-item {
                background: rgba(45, 55, 72, 0.9);
                color: #e0e0e0;
            }
            
            .legend-item:hover {
                background: #4a5568;
            }
        }
        
        /* ===== ANIMATION KEYFRAMES ===== */
        @keyframes slideIn {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        /* Apply animations on load */
        .chart-container,
        .trend-container {
            animation: slideUp 0.6s ease-out;
        }
        
        .sidebar {
            animation: slideIn 0.8s ease-out;
        }
        
        .trend-card:hover {
            animation: pulse 0.6s ease-in-out;
        }
        
        /* ===== UTILITY CLASSES ===== */
        .hidden {
            display: none !important;
        }
        
        .visible {
            display: block !important;
        }
        
        .fade-in {
            opacity: 0;
            animation: fadeIn 0.5s ease-in-out forwards;
        }
        
        .slide-up {
            animation: slideUp 0.5s ease-out;
        }
        
        .text-center {
            text-align: center;
        }
        
        .text-left {
            text-align: left;
        }
        
        .text-right {
            text-align: right;
        }
        
        .mt-10 {
            margin-top: 10px;
        }
        
        .mt-20 {
            margin-top: 20px;
        }
        
        .mb-10 {
            margin-bottom: 10px;
        }
        
        .mb-20 {
            margin-bottom: 20px;
        }
        
        .p-10 {
            padding: 10px;
        }
        
        .p-20 {
            padding: 20px;
        }
        
        /* ===== FOCUS MANAGEMENT ===== */
        .focus-trap {
            position: relative;
        }
        
        .focus-trap:focus-within {
            outline: 3px solid #667eea;
            outline-offset: 2px;
        }
        
        /* ===== CUSTOM SCROLLBARS ===== */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 6px;
            border: 2px solid #f1f1f1;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
        }
        
        ::-webkit-scrollbar-corner {
            background: #f1f1f1;
        }
        
        /* ===== END OF CSS STYLES ===== */
    </style>
    <script>
        /* ===========================================
           PART 2: CORE DATA MANAGEMENT & CONFIGURATION
           =========================================== */
        
        // ===== CHART.JS PLUGIN REGISTRATION =====
        // Register the data labels plugin for displaying values on charts
        if (typeof ChartDataLabels !== 'undefined') {
            Chart.register(ChartDataLabels);
        } else {
            console.warn('ChartDataLabels plugin not available');
            // Fallback: disable data labels
            const showDataLabelsCheckbox = document.getElementById('showDataLabels');
            if (showDataLabelsCheckbox) {
                showDataLabelsCheckbox.checked = false;
                showDataLabelsCheckbox.disabled = true;
            }
        }
        
        // ===== GLOBAL CHART INSTANCES =====
        // Main chart instance for the primary visualization
        let chart = null;
        // Maximized view chart instance (created when user maximizes chart)
        let maximizedChart = null;
        
        // ===== CHART LAYOUT CONFIGURATION =====
        // Controls spacing between year columns within each function group
        let columnSpacing = 1;
        // Controls gap between different function categories
        let categoryGap = 3;
        // Flag to track if chart is currently maximized
        let isChartMaximized = false;
        
        // ===== AXIS CONFIGURATION =====
        // Axis limits and auto-scaling settings
        let axisConfig = {
            primary: {
                min: null,
                max: null,
                autoMin: true,
                autoMax: true
            },
            secondary: {
                min: 0,
                max: 100,
                autoMin: false,
                autoMax: false
            }
        };
        
        // ===== IMAGE STORAGE FOR EXPORTS =====
        // Array to store exported chart images in memory
        let exportedImages = [];
        // Counter for generating unique image names
        let exportCounter = 1;
        
        // ===== YEARS DATA STRUCTURE =====
        // Array containing year configurations with unique IDs for data mapping
        let years = [
            { 
                name: '2024', 
                type: 'previous', 
                id: 'y2024',
                editable: false // Track if currently being edited
            },
            { 
                name: '2025', 
                type: 'current', 
                id: 'y2025',
                editable: false
            }
        ];
        
        // ===== CATEGORIES DATA STRUCTURE =====
        // Array defining the evaluation categories with colors and unique IDs
        let categories = [
            { 
                name: 'Pass', 
                color: '#4CAF50', 
                id: 'pass',
                editable: false // Track if currently being edited
            },
            { 
                name: 'Needs Improvement', 
                color: '#FF9800', 
                id: 'improvement',
                editable: false
            },
            { 
                name: 'Substantiation Issues', 
                color: '#F44336', 
                id: 'issues',
                editable: false
            }
        ];
        
        // ===== FUNCTIONS DATA STRUCTURE =====
        // Array defining the business functions being analyzed
        let functions = [
            { name: 'Treasury', id: 'treasury', editable: false },
            { name: 'FC', id: 'fc', editable: false },
            { name: 'PC', id: 'pc', editable: false },
            { name: 'Tax', id: 'tax', editable: false },
            { name: 'CMA', id: 'cma', editable: false }
        ];
        
        // ===== TEXT STYLING CONFIGURATION =====
        // Configuration object for all text elements in charts
        let textStyles = {
            // Data labels styling (numbers shown on chart bars)
            dataLabels: {
                fontSize: 11,
                color: '#333333',
                fontWeight: 'bold'
            },
            // Axis labels styling (x and y axis text)
            axisLabels: {
                fontSize: 12,
                color: '#666666',
                fontWeight: 'normal'
            },
            // Function names styling (category headers below chart)
            functionNames: {
                fontSize: 14,
                color: '#333333',
                fontWeight: 'bold'
            },
            // Category labels styling (legend and category text)
            categoryLabels: {
                fontSize: 12,
                color: '#333333',
                fontWeight: 'normal'
            },
            // Chart title styling
            title: {
                fontSize: 18,
                color: '#333333',
                fontWeight: 'bold'
            },
            // Legend text styling
            legend: {
                fontSize: 14,
                color: '#333333',
                fontWeight: 'normal'
            }
        };
        
        // ===== TREND LINE CONFIGURATION =====
        // Configuration for each category's trend line display and styling
        let trendLineConfig = {};
        
        // Initialize trend line configurations for each category
        function initializeTrendLineConfig() {
            categories.forEach(category => {
                trendLineConfig[category.id] = {
                    enabled: true,
                    color: category.color,
                    thickness: 2,
                    pointSize: 4,
                    opacity: 1.0,
                    showPoints: true,
                    showLine: true,
                    // Generate complementary color for trend line (darker version of category color)
                    complementaryColor: darkenColor(category.color, 20)
                };
            });
        }
        
        // ===== MAIN DATA STORAGE =====
        // Primary data structure storing all numerical data for functions across years and categories
        let functionData = {};
        
        /**
         * Initialize default data structure for all functions, years, and categories
         * Creates a nested object: functionData[functionId][yearId][categoryIndex] = value
         * @returns {Object} Initialized data structure with default values
         */
        function initializeData() {
            const defaultData = {};
            
            // Iterate through each function
            functions.forEach(func => {
                defaultData[func.id] = {};
                
                // For each function, create entries for all years
                years.forEach(year => {
                    // Initialize array with default values (15, 8, 3) for each category
                    defaultData[func.id][year.id] = [15, 8, 3];
                });
            });
            
            return defaultData;
        }
        
        // ===== DATA ACCESS HELPER FUNCTIONS =====
        
        /**
         * Get the previous year configuration object
         * @returns {Object|null} Previous year object or null if not found
         */
        function getPreviousYear() {
            return years.find(y => y.type === 'previous') || null;
        }
        
        /**
         * Get the current year configuration object
         * @returns {Object|null} Current year object or null if not found
         */
        function getCurrentYear() {
            return years.find(y => y.type === 'current') || null;
        }
        
        /**
         * Get all years of a specific type
         * @param {string} type - 'previous' or 'current'
         * @returns {Array} Array of year objects matching the type
         */
        function getYearsByType(type) {
            return years.filter(y => y.type === type);
        }
        
        /**
         * Find a function by its ID
         * @param {string} functionId - The unique identifier for the function
         * @returns {Object|null} Function object or null if not found
         */
        function getFunctionById(functionId) {
            return functions.find(f => f.id === functionId) || null;
        }
        
        /**
         * Find a category by its ID
         * @param {string} categoryId - The unique identifier for the category
         * @returns {Object|null} Category object or null if not found
         */
        function getCategoryById(categoryId) {
            return categories.find(c => c.id === categoryId) || null;
        }
        
        /**
         * Find a year by its ID
         * @param {string} yearId - The unique identifier for the year
         * @returns {Object|null} Year object or null if not found
         */
        function getYearById(yearId) {
            return years.find(y => y.id === yearId) || null;
        }
        
        /**
         * Find index of a function by its ID
         * @param {string} functionId - The unique identifier for the function
         * @returns {number} Index of function or -1 if not found
         */
        function getFunctionIndexById(functionId) {
            return functions.findIndex(f => f.id === functionId);
        }
        
        /**
         * Find index of a category by its ID
         * @param {string} categoryId - The unique identifier for the category
         * @returns {number} Index of category or -1 if not found
         */
        function getCategoryIndexById(categoryId) {
            return categories.findIndex(c => c.id === categoryId);
        }
        
        /**
         * Find index of a year by its ID
         * @param {string} yearId - The unique identifier for the year
         * @returns {number} Index of year or -1 if not found
         */
        function getYearIndexById(yearId) {
            return years.findIndex(y => y.id === yearId);
        }
        
        // ===== DATA VALIDATION FUNCTIONS =====
        
        /**
         * Validate that a function exists and has data
         * @param {string} functionId - Function ID to validate
         * @returns {boolean} True if function exists and has data
         */
        function validateFunction(functionId) {
            return functionId && 
                   functions.some(f => f.id === functionId) && 
                   functionData[functionId] !== undefined;
        }
        
        /**
         * Validate that a year exists
         * @param {string} yearId - Year ID to validate
         * @returns {boolean} True if year exists
         */
        function validateYear(yearId) {
            return yearId && years.some(y => y.id === yearId);
        }
        
        /**
         * Validate that a category index is within bounds
         * @param {number} categoryIndex - Category index to validate
         * @returns {boolean} True if category index is valid
         */
        function validateCategory(categoryIndex) {
            return typeof categoryIndex === 'number' && 
                   categoryIndex >= 0 && 
                   categoryIndex < categories.length;
        }
        
        /**
         * Validate that a name is unique within a collection
         * @param {string} name - Name to validate
         * @param {Array} collection - Collection to check against
         * @param {string} excludeId - ID to exclude from uniqueness check (for renames)
         * @returns {boolean} True if name is unique
         */
        function validateUniqueName(name, collection, excludeId = null) {
            return !collection.some(item => 
                item.name.toLowerCase() === name.toLowerCase() && 
                item.id !== excludeId
            );
        }
        
        // ===== DATA MANIPULATION FUNCTIONS =====
        
        /**
         * Get data value for a specific function, year, and category
         * @param {string} functionId - Function identifier
         * @param {string} yearId - Year identifier  
         * @param {number} categoryIndex - Category index
         * @returns {number} Data value or 0 if not found
         */
        function getDataValue(functionId, yearId, categoryIndex) {
            if (!validateFunction(functionId) || !validateYear(yearId) || !validateCategory(categoryIndex)) {
                return 0;
            }
            
            return functionData[functionId][yearId][categoryIndex] || 0;
        }
        
        /**
         * Set data value for a specific function, year, and category
         * @param {string} functionId - Function identifier
         * @param {string} yearId - Year identifier
         * @param {number} categoryIndex - Category index
         * @param {number} value - Value to set
         * @returns {boolean} True if value was set successfully
         */
        function setDataValue(functionId, yearId, categoryIndex, value) {
            if (!validateFunction(functionId) || !validateYear(yearId) || !validateCategory(categoryIndex)) {
                return false;
            }
            
            // Ensure the data structure exists
            if (!functionData[functionId]) {
                functionData[functionId] = {};
            }
            if (!functionData[functionId][yearId]) {
                functionData[functionId][yearId] = new Array(categories.length).fill(0);
            }
            
            // Set the value (ensure it's a number and non-negative)
            functionData[functionId][yearId][categoryIndex] = Math.max(0, parseInt(value) || 0);
            return true;
        }
        
        /**
         * Get total count for a function in a specific year
         * @param {string} functionId - Function identifier
         * @param {string} yearId - Year identifier
         * @returns {number} Total count across all categories
         */
        function getFunctionYearTotal(functionId, yearId) {
            if (!validateFunction(functionId) || !validateYear(yearId)) {
                return 0;
            }
            
            return functionData[functionId][yearId].reduce((sum, val) => sum + val, 0);
        }
        
        /**
         * Get percentage for a specific category within a function-year combination
         * @param {string} functionId - Function identifier
         * @param {string} yearId - Year identifier
         * @param {number} categoryIndex - Category index
         * @returns {number} Percentage rounded to 2 decimal places
         */
        function getCategoryPercentage(functionId, yearId, categoryIndex) {
            const total = getFunctionYearTotal(functionId, yearId);
            if (total === 0) return 0;
            
            const value = getDataValue(functionId, yearId, categoryIndex);
            return parseFloat(((value / total) * 100).toFixed(2));
        }
        
        /**
         * Calculate year-over-year percentage point change for a category
         * @param {string} functionId - Function identifier
         * @param {number} categoryIndex - Category index
         * @returns {number} Percentage point change rounded to 2 decimal places
         */
        function getYearOverYearChange(functionId, categoryIndex) {
            const prevYear = getPreviousYear();
            const currYear = getCurrentYear();
            
            if (!prevYear || !currYear) return 0;
            
            const prevPercentage = getCategoryPercentage(functionId, prevYear.id, categoryIndex);
            const currPercentage = getCategoryPercentage(functionId, currYear.id, categoryIndex);
            
            return parseFloat((currPercentage - prevPercentage).toFixed(2));
        }
        
        // ===== AXIS CONFIGURATION FUNCTIONS =====
        
        /**
         * Get axis configuration for chart scales
         * @param {string} axisType - 'primary' or 'secondary'
         * @returns {Object} Axis configuration object
         */
        function getAxisConfig(axisType) {
            const config = axisConfig[axisType];
            if (!config) return {};
            
            const result = {};
            
            // Set min value
            if (!config.autoMin && config.min !== null && config.min !== '') {
                result.min = parseFloat(config.min);
            }
            
            // Set max value
            if (!config.autoMax && config.max !== null && config.max !== '') {
                result.max = parseFloat(config.max);
            }
            
            // Always begin at zero for primary axis if auto
            if (axisType === 'primary' && config.autoMin) {
                result.beginAtZero = true;
            }
            
            return result;
        }
        
        /**
         * Update axis configuration
         * @param {string} axisType - 'primary' or 'secondary'
         * @param {string} property - Property to update ('min', 'max', 'autoMin', 'autoMax')
         * @param {*} value - New value
         */
        function updateAxisConfig(axisType, property, value) {
            if (!axisConfig[axisType]) {
                axisConfig[axisType] = { min: null, max: null, autoMin: true, autoMax: true };
            }
            
            axisConfig[axisType][property] = value;
            
            // If enabling auto, clear the manual value
            if (property === 'autoMin' && value === true) {
                axisConfig[axisType].min = null;
            } else if (property === 'autoMax' && value === true) {
                axisConfig[axisType].max = null;
            }
        }
        
        // ===== COLOR UTILITY FUNCTIONS =====
        
        /**
         * Convert hex color to RGB values
         * @param {string} hex - Hex color code (e.g., "#FF0000")
         * @returns {Object} RGB object with r, g, b properties
         */
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        /**
         * Convert RGB values to hex color
         * @param {number} r - Red value (0-255)
         * @param {number} g - Green value (0-255)
         * @param {number} b - Blue value (0-255)
         * @returns {string} Hex color code
         */
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        /**
         * Darken a hex color by a specified percentage
         * @param {string} hex - Original hex color
         * @param {number} percent - Percentage to darken (0-100)
         * @returns {string} Darkened hex color
         */
        function darkenColor(hex, percent) {
            const rgb = hexToRgb(hex);
            if (!rgb) return hex;
            
            const factor = (100 - percent) / 100;
            const r = Math.round(rgb.r * factor);
            const g = Math.round(rgb.g * factor);
            const b = Math.round(rgb.b * factor);
            
            return rgbToHex(r, g, b);
        }
        
        /**
         * Lighten a hex color by a specified percentage
         * @param {string} hex - Original hex color
         * @param {number} percent - Percentage to lighten (0-100)
         * @returns {string} Lightened hex color
         */
        function lightenColor(hex, percent) {
            const rgb = hexToRgb(hex);
            if (!rgb) return hex;
            
            const factor = percent / 100;
            const r = Math.round(rgb.r + (255 - rgb.r) * factor);
            const g = Math.round(rgb.g + (255 - rgb.g) * factor);
            const b = Math.round(rgb.b + (255 - rgb.b) * factor);
            
            return rgbToHex(r, g, b);
        }
        
        /**
         * Get opacity value based on shading mode and year type
         * @param {string} yearType - 'previous' or 'current'
         * @returns {string} Hex opacity value (00-FF)
         */
        function getOpacity(yearType) {
            const shadingMode = document.querySelector('input[name="shading"]:checked')?.value || 'auto';
            
            if (shadingMode === 'auto') {
                // Auto mode: previous year is lighter (80% opacity), current year is full opacity
                return yearType === 'previous' ? '80' : 'FF';
            } else {
                // Manual mode: get opacity from slider controls
                const prevOpacity = document.getElementById('prevOpacity')?.value || 50;
                const currOpacity = document.getElementById('currOpacity')?.value || 100;
                const opacity = yearType === 'previous' ? prevOpacity : currOpacity;
                
                // Convert percentage to hex (0-255 range)
                return Math.round((opacity / 100) * 255).toString(16).padStart(2, '0');
            }
        }
        
        /**
         * Generate a complementary color palette for trend lines
         * @param {string} baseColor - Base hex color
         * @returns {Object} Object with various color variations
         */
        function generateColorPalette(baseColor) {
            return {
                base: baseColor,
                light: lightenColor(baseColor, 20),
                dark: darkenColor(baseColor, 20),
                veryLight: lightenColor(baseColor, 40),
                veryDark: darkenColor(baseColor, 40)
            };
        }
        
        // ===== ID GENERATION FUNCTIONS =====
        
        /**
         * Generate a unique ID for new items
         * @param {string} baseName - Base name to generate ID from
         * @param {Array} collection - Existing collection to check against
         * @returns {string} Unique ID
         */
        function generateUniqueId(baseName, collection) {
            let baseId = baseName.toLowerCase()
                .replace(/\s+/g, '_')
                .replace(/[^a-z0-9_]/g, '');
            
            // If base ID is empty, use a generic prefix
            if (!baseId) {
                baseId = 'item';
            }
            
            // Check if ID already exists
            let counter = 1;
            let finalId = baseId;
            
            while (collection.some(item => item.id === finalId)) {
                finalId = baseId + '_' + counter;
                counter++;
            }
            
            return finalId;
        }
        
        // ===== DATA STRUCTURE MANAGEMENT =====
        
        /**
         * Add a new function to the data structure
         * @param {string} name - Function name
         * @returns {Object} New function object or null if failed
         */
        function addFunctionToData(name) {
            if (!name || !validateUniqueName(name, functions)) {
                return null;
            }
            
            const id = generateUniqueId(name, functions);
            const newFunction = { name, id, editable: false };
            
            // Add to functions array
            functions.push(newFunction);
            
            // Initialize data for new function
            functionData[id] = {};
            years.forEach(year => {
                functionData[id][year.id] = new Array(categories.length).fill(0);
            });
            
            return newFunction;
        }
        
        /**
         * Add a new category to the data structure
         * @param {string} name - Category name
         * @param {string} color - Category color
         * @returns {Object} New category object or null if failed
         */
        function addCategoryToData(name, color) {
            if (!name || !validateUniqueName(name, categories)) {
                return null;
            }
            
            const id = generateUniqueId(name, categories);
            const newCategory = { name, color, id, editable: false };
            
            // Add to categories array
            categories.push(newCategory);
            
            // Add new category data to all functions and years
            functions.forEach(func => {
                years.forEach(year => {
                    if (!functionData[func.id]) functionData[func.id] = {};
                    if (!functionData[func.id][year.id]) functionData[func.id][year.id] = [];
                    functionData[func.id][year.id].push(0);
                });
            });
            
            // Initialize trend line configuration for new category
            trendLineConfig[id] = {
                enabled: true,
                color: color,
                thickness: 2,
                pointSize: 4,
                opacity: 1.0,
                showPoints: true,
                showLine: true,
                complementaryColor: darkenColor(color, 20)
            };
            
            return newCategory;
        }
        
        /**
         * Add a new year to the data structure
         * @param {string} name - Year name
         * @param {string} type - Year type ('previous' or 'current')
         * @returns {Object} New year object or null if failed
         */
        function addYearToData(name, type) {
            if (!name || !validateUniqueName(name, years)) {
                return null;
            }
            
            // Handle type conflicts
            const existingType = years.find(y => y.type === type);
            if (existingType) {
                existingType.type = type === 'previous' ? 'current' : 'previous';
            }
            
            const id = generateUniqueId(name, years);
            const newYear = { name, type, id, editable: false };
            
            // Add to years array
            years.push(newYear);
            
            // Initialize data for new year across all functions
            functions.forEach(func => {
                if (!functionData[func.id]) functionData[func.id] = {};
                functionData[func.id][id] = new Array(categories.length).fill(0);
            });
            
            return newYear;
        }
        
        /**
         * Remove a function from the data structure
         * @param {number} index - Index of function to remove
         * @returns {boolean} True if removed successfully
         */
        function removeFunctionFromData(index) {
            if (index < 0 || index >= functions.length || functions.length <= 1) {
                return false;
            }
            
            const func = functions[index];
            
            // Remove function data
            delete functionData[func.id];
            
            // Remove function from array
            functions.splice(index, 1);
            
            return true;
        }
        
        /**
         * Remove a category from the data structure
         * @param {number} index - Index of category to remove
         * @returns {boolean} True if removed successfully
         */
        function removeCategoryFromData(index) {
            if (index < 0 || index >= categories.length || categories.length <= 1) {
                return false;
            }
            
            const category = categories[index];
            
            // Remove category data from all functions and years
            functions.forEach(func => {
                years.forEach(year => {
                    if (functionData[func.id] && functionData[func.id][year.id]) {
                        functionData[func.id][year.id].splice(index, 1);
                    }
                });
            });
            
            // Remove trend line configuration
            delete trendLineConfig[category.id];
            
            // Remove category from array
            categories.splice(index, 1);
            
            return true;
        }
        
        /**
         * Remove a year from the data structure
         * @param {number} index - Index of year to remove
         * @returns {boolean} True if removed successfully
         */
        function removeYearFromData(index) {
            if (index < 0 || index >= years.length || years.length <= 1) {
                return false;
            }
            
            const year = years[index];
            
            // Remove data for this year from all functions
            functions.forEach(func => {
                if (functionData[func.id]) {
                    delete functionData[func.id][year.id];
                }
            });
            
            // Remove year from array
            years.splice(index, 1);
            
            return true;
        }
        
        // ===== CHART CONFIGURATION OBJECTS =====
        
        /**
         * Get default Chart.js configuration for main chart
         * @returns {Object} Chart.js configuration object
         */
        function getDefaultChartConfig() {
            return {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: document.getElementById('animation')?.value === 'true' ? 750 : 0,
                    easing: 'easeInOutQuart'
                },
                layout: {
                    padding: {
                        top: 40,
                        bottom: 20,
                        left: 10,
                        right: 10
                    }
                },
                plugins: {
                    legend: {
                        display: false // We use custom legend
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'index',
                        intersect: false,
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        titleColor: '#fff',
                        bodyColor: '#fff',
                        borderColor: '#667eea',
                        borderWidth: 2,
                        cornerRadius: 8,
                        displayColors: true,
                        callbacks: {
                            // Custom tooltip formatting will be added in chart creation
                        }
                    },
                    datalabels: {
                        display: false // Controlled separately for each dataset
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: textStyles.axisLabels.color,
                            font: {
                                size: textStyles.axisLabels.fontSize,
                                weight: textStyles.axisLabels.fontWeight
                            },
                            maxRotation: 45,
                            minRotation: 0
                        }
                    },
                    y: {
                        stacked: true,
                        ...getAxisConfig('primary'),
                        grid: {
                            color: 'rgba(0,0,0,0.1)',
                            lineWidth: 1
                        },
                        ticks: {
                            color: textStyles.axisLabels.color,
                            font: {
                                size: textStyles.axisLabels.fontSize,
                                weight: textStyles.axisLabels.fontWeight
                            }
                        },
                        title: {
                            display: true,
                            text: 'Number of Accounts',
                            color: textStyles.title.color,
                            font: {
                                size: textStyles.title.fontSize,
                                weight: textStyles.title.fontWeight
                            }
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: false, // Will be enabled when trend lines are shown
                        position: 'right',
                        ...getAxisConfig('secondary'),
                        grid: {
                            drawOnChartArea: false
                        },
                        ticks: {
                            color: textStyles.axisLabels.color,
                            font: {
                                size: textStyles.axisLabels.fontSize,
                                weight: textStyles.axisLabels.fontWeight
                            },
                            callback: function(value) {
                                return value + '%';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Percentage (%)',
                            color: textStyles.title.color,
                            font: {
                                size: textStyles.title.fontSize,
                                weight: textStyles.title.fontWeight
                            }
                        }
                    }
                }
            };
        }
        
        // ===== INITIALIZATION =====
        // Initialize the main data structure with default values
        functionData = initializeData();
        
        // Initialize trend line configurations
        initializeTrendLineConfig();
        
        // ===== DEBUG FUNCTIONS (for development) =====
        
        /**
         * Log current data structure to console (for debugging)
         */
        function debugLogData() {
            console.log('=== Current Data Structure ===');
            console.log('Functions:', functions);
            console.log('Years:', years);
            console.log('Categories:', categories);
            console.log('Function Data:', functionData);
            console.log('Text Styles:', textStyles);
            console.log('Trend Line Config:', trendLineConfig);
            console.log('Axis Config:', axisConfig);
        }
        
        /**
         * Validate entire data structure integrity
         * @returns {Object} Validation result with status and any issues found
         */
        function validateDataIntegrity() {
            const issues = [];
            
            // Check if all functions have data for all years
            functions.forEach(func => {
                if (!functionData[func.id]) {
                    issues.push(`Missing data for function: ${func.name}`);
                    return;
                }
                
                years.forEach(year => {
                    if (!functionData[func.id][year.id]) {
                        issues.push(`Missing data for function ${func.name}, year ${year.name}`);
                    } else if (functionData[func.id][year.id].length !== categories.length) {
                        issues.push(`Incorrect data length for function ${func.name}, year ${year.name}`);
                    }
                });
            });
            
            // Check for duplicate IDs
            const functionIds = functions.map(f => f.id);
            const yearIds = years.map(y => y.id);
            const categoryIds = categories.map(c => c.id);
            
            if (new Set(functionIds).size !== functionIds.length) {
                issues.push('Duplicate function IDs detected');
            }
            if (new Set(yearIds).size !== yearIds.length) {
                issues.push('Duplicate year IDs detected');
            }
            if (new Set(categoryIds).size !== categoryIds.length) {
                issues.push('Duplicate category IDs detected');
            }
            
            // Check for required year types
            const hasPrevious = years.some(y => y.type === 'previous');
            const hasCurrent = years.some(y => y.type === 'current');
            
            if (!hasPrevious) {
                issues.push('No year designated as "previous"');
            }
            if (!hasCurrent) {
                issues.push('No year designated as "current"');
            }
            
            return {
                valid: issues.length === 0,
                issues: issues
            };
        }
        
        // ===== RENAME FUNCTIONALITY =====
        
        /**
         * Start editing mode for a function
         * @param {number} index - Index of function to edit
         * @returns {boolean} True if edit mode started successfully
         */
        function startEditFunction(index) {
            if (index < 0 || index >= functions.length) {
                return false;
            }
            
            // Cancel any other edit modes
            cancelAllEditModes();
            
            functions[index].editable = true;
            return true;
        }
        
        /**
         * Start editing mode for a category
         * @param {number} index - Index of category to edit
         * @returns {boolean} True if edit mode started successfully
         */
        function startEditCategory(index) {
            if (index < 0 || index >= categories.length) {
                return false;
            }
            
            // Cancel any other edit modes
            cancelAllEditModes();
            
            categories[index].editable = true;
            return true;
        }
        
        /**
         * Start editing mode for a year
         * @param {number} index - Index of year to edit
         * @returns {boolean} True if edit mode started successfully
         */
        function startEditYear(index) {
            if (index < 0 || index >= years.length) {
                return false;
            }
            
            // Cancel any other edit modes
            cancelAllEditModes();
            
            years[index].editable = true;
            return true;
        }
        
        /**
         * Cancel all edit modes
         */
        function cancelAllEditModes() {
            functions.forEach(func => func.editable = false);
            categories.forEach(category => category.editable = false);
            years.forEach(year => year.editable = false);
        }
        
        /**
         * Save function name edit
         * @param {number} index - Index of function being edited
         * @param {string} newName - New name for the function
         * @returns {boolean} True if save was successful
         */
        function saveFunctionEdit(index, newName) {
            if (index < 0 || index >= functions.length) {
                return false;
            }
            
            const func = functions[index];
            const trimmedName = newName.trim();
            
            // Validate new name
            if (!trimmedName) {
                return false;
            }
            
            if (!validateUniqueName(trimmedName, functions, func.id)) {
                return false;
            }
            
            // Update name and exit edit mode
            func.name = trimmedName;
            func.editable = false;
            
            return true;
        }
        
        /**
         * Save category name edit
         * @param {number} index - Index of category being edited
         * @param {string} newName - New name for the category
         * @returns {boolean} True if save was successful
         */
        function saveCategoryEdit(index, newName) {
            if (index < 0 || index >= categories.length) {
                return false;
            }
            
            const category = categories[index];
            const trimmedName = newName.trim();
            
            // Validate new name
            if (!trimmedName) {
                return false;
            }
            
            if (!validateUniqueName(trimmedName, categories, category.id)) {
                return false;
            }
            
            // Update name and exit edit mode
            category.name = trimmedName;
            category.editable = false;
            
            return true;
        }
        
        /**
         * Save year name edit
         * @param {number} index - Index of year being edited
         * @param {string} newName - New name for the year
         * @returns {boolean} True if save was successful
         */
        function saveYearEdit(index, newName) {
            if (index < 0 || index >= years.length) {
                return false;
            }
            
            const year = years[index];
            const trimmedName = newName.trim();
            
            // Validate new name
            if (!trimmedName) {
                return false;
            }
            
            if (!validateUniqueName(trimmedName, years, year.id)) {
                return false;
            }
            
            // Update name and exit edit mode
            year.name = trimmedName;
            year.editable = false;
            
            return true;
        }
        
        /**
         * Cancel edit mode for a function
         * @param {number} index - Index of function to cancel edit
         * @returns {boolean} True if cancel was successful
         */
        function cancelFunctionEdit(index) {
            if (index < 0 || index >= functions.length) {
                return false;
            }
            
            functions[index].editable = false;
            return true;
        }
        
        /**
         * Cancel edit mode for a category
         * @param {number} index - Index of category to cancel edit
         * @returns {boolean} True if cancel was successful
         */
        function cancelCategoryEdit(index) {
            if (index < 0 || index >= categories.length) {
                return false;
            }
            
            categories[index].editable = false;
            return true;
        }
        
        /**
         * Cancel edit mode for a year
         * @param {number} index - Index of year to cancel edit
         * @returns {boolean} True if cancel was successful
         */
        function cancelYearEdit(index) {
            if (index < 0 || index >= years.length) {
                return false;
            }
            
            years[index].editable = false;
            return true;
        }
        
        // ===== SORTING AND ORDERING FUNCTIONS =====
        
        /**
         * Move function up in the order
         * @param {number} index - Current index of function
         * @returns {boolean} True if moved successfully
         */
        function moveFunctionUp(index) {
            if (index <= 0 || index >= functions.length) {
                return false;
            }
            
            [functions[index], functions[index - 1]] = [functions[index - 1], functions[index]];
            return true;
        }
        
        /**
         * Move function down in the order
         * @param {number} index - Current index of function
         * @returns {boolean} True if moved successfully
         */
        function moveFunctionDown(index) {
            if (index < 0 || index >= functions.length - 1) {
                return false;
            }
            
            [functions[index], functions[index + 1]] = [functions[index + 1], functions[index]];
            return true;
        }
        
        /**
         * Get sorted functions based on current sort settings
         * @returns {Array} Sorted array of functions
         */
        function getSortedFunctions() {
            const sortBy = document.getElementById('sortBy')?.value || 'default';
            const sortDirection = document.getElementById('sortDirection')?.value || 'asc';
            
            let sortedFunctions = [...functions];
            const prevYear = getPreviousYear();
            const currYear = getCurrentYear();
            
            if (!prevYear || !currYear) return sortedFunctions;
            
            switch (sortBy) {
                case 'name':
                    sortedFunctions.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                    
                case 'totalPrevious':
                    sortedFunctions.sort((a, b) => {
                        const totalA = getFunctionYearTotal(a.id, prevYear.id);
                        const totalB = getFunctionYearTotal(b.id, prevYear.id);
                        return totalA - totalB;
                    });
                    break;
                    
                case 'totalCurrent':
                    sortedFunctions.sort((a, b) => {
                        const totalA = getFunctionYearTotal(a.id, currYear.id);
                        const totalB = getFunctionYearTotal(b.id, currYear.id);
                        return totalA - totalB;
                    });
                    break;
                    
                case 'improvement':
                    sortedFunctions.sort((a, b) => {
                        const improvementA = getYearOverYearChange(a.id, 0); // Use first category for improvement
                        const improvementB = getYearOverYearChange(b.id, 0);
                        return improvementA - improvementB;
                    });
                    break;
                    
                case 'passRateCurrent':
                    sortedFunctions.sort((a, b) => {
                        const passRateA = getCategoryPercentage(a.id, currYear.id, 0);
                        const passRateB = getCategoryPercentage(b.id, currYear.id, 0);
                        return passRateA - passRateB;
                    });
                    break;
                    
                default:
                    // Keep original order
                    break;
            }
            
            if (sortDirection === 'desc') {
                sortedFunctions.reverse();
            }
            
            return sortedFunctions;
        }
        
        // ===== EXPORT/IMPORT DATA FUNCTIONS =====
        
        /**
         * Export all dashboard configuration and data as JSON
         * @returns {string} JSON string of complete dashboard state
         */
        function exportDashboardData() {
            const dashboardState = {
                version: '2.0',
                timestamp: new Date().toISOString(),
                configuration: {
                    years: years.map(y => ({ ...y, editable: false })), // Remove edit states
                    categories: categories.map(c => ({ ...c, editable: false })),
                    functions: functions.map(f => ({ ...f, editable: false })),
                    functionData: functionData,
                    textStyles: textStyles,
                    trendLineConfig: trendLineConfig,
                    columnSpacing: columnSpacing,
                    categoryGap: categoryGap,
                    axisConfig: axisConfig
                },
                metadata: {
                    exportCount: exportCounter,
                    totalFunctions: functions.length,
                    totalCategories: categories.length,
                    totalYears: years.length
                }
            };
            
            return JSON.stringify(dashboardState, null, 2);
        }
        
        /**
         * Import dashboard configuration from JSON data
         * @param {string} jsonData - JSON string containing dashboard state
         * @returns {Object} Import result with success status and any errors
         */
        function importDashboardData(jsonData) {
            try {
                const dashboardState = JSON.parse(jsonData);
                
                // Validate data structure
                if (!dashboardState.configuration) {
                    throw new Error('Invalid data format: missing configuration');
                }
                
                const config = dashboardState.configuration;
                const errors = [];
                
                // Validate required arrays
                if (!Array.isArray(config.years) || config.years.length === 0) {
                    errors.push('Invalid or empty years array');
                }
                
                if (!Array.isArray(config.categories) || config.categories.length === 0) {
                    errors.push('Invalid or empty categories array');
                }
                
                if (!Array.isArray(config.functions) || config.functions.length === 0) {
                    errors.push('Invalid or empty functions array');
                }
                
                if (errors.length > 0) {
                    return { success: false, errors: errors };
                }
                
                // Import data with validation
                if (config.years) {
                    years = config.years.map(y => ({ ...y, editable: false }));
                }
                if (config.categories) {
                    categories = config.categories.map(c => ({ ...c, editable: false }));
                }
                if (config.functions) {
                    functions = config.functions.map(f => ({ ...f, editable: false }));
                }
                if (config.functionData && typeof config.functionData === 'object') {
                    functionData = config.functionData;
                }
                if (config.textStyles && typeof config.textStyles === 'object') {
                    textStyles = { ...textStyles, ...config.textStyles };
                }
                if (config.trendLineConfig && typeof config.trendLineConfig === 'object') {
                    trendLineConfig = { ...trendLineConfig, ...config.trendLineConfig };
                }
                if (typeof config.columnSpacing === 'number') {
                    columnSpacing = config.columnSpacing;
                }
                if (typeof config.categoryGap === 'number') {
                    categoryGap = config.categoryGap;
                }
                if (config.axisConfig && typeof config.axisConfig === 'object') {
                    axisConfig = { ...axisConfig, ...config.axisConfig };
                }
                
                return { success: true, errors: [] };
                
            } catch (error) {
                console.error('Error importing dashboard data:', error);
                return { success: false, errors: [error.message] };
            }
        }
        
        // ===== PERFORMANCE OPTIMIZATION FUNCTIONS =====
        
        /**
         * Optimize data structures for performance
         */
        function optimizeDataStructures() {
            // Remove any null or undefined entries
            functions = functions.filter(f => f && f.id);
            categories = categories.filter(c => c && c.id);
            years = years.filter(y => y && y.id);
            
            // Clean up orphaned data
            Object.keys(functionData).forEach(funcId => {
                if (!functions.some(f => f.id === funcId)) {
                    delete functionData[funcId];
                } else {
                    Object.keys(functionData[funcId]).forEach(yearId => {
                        if (!years.some(y => y.id === yearId)) {
                            delete functionData[funcId][yearId];
                        } else {
                            // Ensure data array has correct length
                            const expectedLength = categories.length;
                            const currentLength = functionData[funcId][yearId].length;
                            
                            if (currentLength < expectedLength) {
                                // Pad with zeros
                                functionData[funcId][yearId] = [
                                    ...functionData[funcId][yearId],
                                    ...new Array(expectedLength - currentLength).fill(0)
                                ];
                            } else if (currentLength > expectedLength) {
                                // Trim excess
                                functionData[funcId][yearId] = functionData[funcId][yearId].slice(0, expectedLength);
                            }
                        }
                    });
                }
            });
            
            // Clean up orphaned trend line configs
            Object.keys(trendLineConfig).forEach(categoryId => {
                if (!categories.some(c => c.id === categoryId)) {
                    delete trendLineConfig[categoryId];
                }
            });
        }
        
        /**
         * Reset all data to defaults
         */
        function resetToDefaults() {
            // Reset to initial state
            years = [
                { name: '2024', type: 'previous', id: 'y2024', editable: false },
                { name: '2025', type: 'current', id: 'y2025', editable: false }
            ];
            
            categories = [
                { name: 'Pass', color: '#4CAF50', id: 'pass', editable: false },
                { name: 'Needs Improvement', color: '#FF9800', id: 'improvement', editable: false },
                { name: 'Substantiation Issues', color: '#F44336', id: 'issues', editable: false }
            ];
            
            functions = [
                { name: 'Treasury', id: 'treasury', editable: false },
                { name: 'FC', id: 'fc', editable: false },
                { name: 'PC', id: 'pc', editable: false },
                { name: 'Tax', id: 'tax', editable: false },
                { name: 'CMA', id: 'cma', editable: false }
            ];
            
            // Reset configurations
            columnSpacing = 1;
            categoryGap = 3;
            
            axisConfig = {
                primary: {
                    min: null,
                    max: null,
                    autoMin: true,
                    autoMax: true
                },
                secondary: {
                    min: 0,
                    max: 100,
                    autoMin: false,
                    autoMax: false
                }
            };
            
            textStyles = {
                dataLabels: { fontSize: 11, color: '#333333', fontWeight: 'bold' },
                axisLabels: { fontSize: 12, color: '#666666', fontWeight: 'normal' },
                functionNames: { fontSize: 14, color: '#333333', fontWeight: 'bold' },
                categoryLabels: { fontSize: 12, color: '#333333', fontWeight: 'normal' },
                title: { fontSize: 18, color: '#333333', fontWeight: 'bold' },
                legend: { fontSize: 14, color: '#333333', fontWeight: 'normal' }
            };
            
            // Reinitialize data and trend line config
            functionData = initializeData();
            initializeTrendLineConfig();
        }
        
        /* ===========================================
           END OF PART 2: CORE DATA MANAGEMENT & CONFIGURATION
           =========================================== */
        /* ===========================================
           PART 3: UI RENDERING & DOM MANAGEMENT
           =========================================== */
        
        // ===== THROTTLING VARIABLES =====
        let updateTimeout = null;
        const UPDATE_DELAY = 300; // milliseconds to wait before updating charts
        
        // ===== DOM MANIPULATION & RENDERING FUNCTIONS =====
        
        /**
         * Render the years list in the sidebar with add/remove/toggle/rename controls
         * Updates the years configuration section with current year data
         */
        function renderYears() {
            const container = document.getElementById('yearsList');
            if (!container) return;
            
            container.innerHTML = '';
            
            years.forEach((year, index) => {
                const item = document.createElement('div');
                item.className = 'year-item fade-in';
                item.setAttribute('role', 'listitem');
                item.setAttribute('aria-label', `Year ${year.name} configured as ${year.type}`);
                
                // Create year name display/edit element
                const yearNameElement = year.editable 
                    ? `<input type="text" 
                              class="item-name-input" 
                              value="${year.name}" 
                              onblur="saveYearEdit(${index}, this.value)"
                              onkeydown="handleEditKeydown(event, ${index}, 'year', this.value)"
                              aria-label="Edit year name"
                              autofocus>`
                    : `<span style="font-weight: 600; font-size: 16px; cursor: pointer;" 
                             onclick="startEditYear(${index})"
                             title="Click to rename">${year.name}</span>`;
                
                item.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        ${yearNameElement}
                        <span class="year-indicator ${year.type === 'previous' ? 'previous-year' : 'current-year'}">
                            ${year.type === 'previous' ? 'Previous' : 'Current'}
                        </span>
                    </div>
                    <div class="year-controls">
                        ${!year.editable ? `
                            <button onclick="toggleYearType(${index})" 
                                    aria-label="Switch ${year.name} to ${year.type === 'previous' ? 'Current' : 'Previous'} year"
                                    title="Switch year type">
                                Switch to ${year.type === 'previous' ? 'Current' : 'Previous'}
                            </button>
                            <button class="edit-button" 
                                    onclick="startEditYear(${index})" 
                                    aria-label="Rename ${year.name}"
                                    title="Rename this year">
                                Rename
                            </button>
                            ${years.length > 1 ? `
                                <button class="remove-button" 
                                        onclick="removeYear(${index})" 
                                        aria-label="Remove ${year.name}"
                                        title="Remove this year">
                                    Remove
                                </button>
                            ` : ''}
                        ` : `
                            <button onclick="saveYearEdit(${index}, document.querySelector('.item-name-input').value)" 
                                    aria-label="Save changes"
                                    title="Save changes">
                                Save
                            </button>
                            <button onclick="cancelYearEdit(${index})" 
                                    aria-label="Cancel editing"
                                    title="Cancel editing">
                                Cancel
                            </button>
                        `}
                    </div>
                `;
                container.appendChild(item);
            });
            
            // Update trend line controls after year changes
            renderTrendLineControls();
        }
        
        /**
         * Render the categories list with color indicators, rename, and remove buttons
         * Updates the categories section in the sidebar
         */
        function renderCategories() {
            const container = document.getElementById('categoriesList');
            if (!container) return;
            
            container.innerHTML = '';
            
            categories.forEach((category, index) => {
                const item = document.createElement('div');
                item.className = 'item fade-in';
                item.setAttribute('role', 'listitem');
                item.setAttribute('aria-label', `Category ${category.name} with color ${category.color}`);
                
                // Create category name display/edit element
                const categoryNameElement = category.editable
                    ? `<input type="text" 
                              class="item-name-input" 
                              value="${category.name}" 
                              onblur="saveCategoryEdit(${index}, this.value)"
                              onkeydown="handleEditKeydown(event, ${index}, 'category', this.value)"
                              aria-label="Edit category name"
                              autofocus>`
                    : `<span style="font-weight: 500; cursor: pointer;" 
                             onclick="startEditCategory(${index})"
                             title="Click to rename">${category.name}</span>`;
                
                item.innerHTML = `
                    <div class="item-info">
                        <div class="item-color" 
                             style="background-color: ${category.color}" 
                             aria-label="${category.name} color indicator"
                             title="Category color: ${category.color}"></div>
                        ${categoryNameElement}
                    </div>
                    <div style="display: flex; gap: 8px;">
                        ${!category.editable ? `
                            <button class="edit-button" 
                                    onclick="startEditCategory(${index})" 
                                    aria-label="Rename ${category.name}"
                                    title="Rename this category">
                                Rename
                            </button>
                            ${categories.length > 1 ? `
                                <button class="remove-button" 
                                        onclick="removeCategory(${index})" 
                                        aria-label="Remove ${category.name} category"
                                        title="Remove this category">
                                    Remove
                                </button>
                            ` : ''}
                        ` : `
                            <button onclick="saveCategoryEdit(${index}, document.querySelector('.item-name-input').value)" 
                                    aria-label="Save changes"
                                    title="Save changes">
                                Save
                            </button>
                            <button onclick="cancelCategoryEdit(${index})" 
                                    aria-label="Cancel editing"
                                    title="Cancel editing">
                                Cancel
                            </button>
                        `}
                    </div>
                `;
                container.appendChild(item);
            });
            
            // Update trend line controls when categories change
            renderTrendLineControls();
        }
        
        /**
         * Render the functions list with sorting controls, rename, and remove buttons
         * Updates the functions management section in the sidebar
         */
        function renderFunctions() {
            const container = document.getElementById('functionsList');
            if (!container) return;
            
            container.innerHTML = '';
            
            functions.forEach((func, index) => {
                const item = document.createElement('div');
                item.className = 'sort-item fade-in';
                item.setAttribute('role', 'listitem');
                item.setAttribute('aria-label', `Function ${func.name} at position ${index + 1}`);
                
                // Create function name display/edit element
                const functionNameElement = func.editable
                    ? `<input type="text" 
                              class="item-name-input" 
                              value="${func.name}" 
                              onblur="saveFunctionEdit(${index}, this.value)"
                              onkeydown="handleEditKeydown(event, ${index}, 'function', this.value)"
                              aria-label="Edit function name"
                              autofocus
                              style="flex: 1;">`
                    : `<span style="font-weight: 500; flex: 1; cursor: pointer;" 
                             onclick="startEditFunction(${index})"
                             title="Click to rename">${func.name}</span>`;
                
                item.innerHTML = `
                    ${functionNameElement}
                    <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                        ${!func.editable ? `
                            <button onclick="moveFunctionUp(${index})" 
                                    ${index === 0 ? 'disabled' : ''} 
                                    aria-label="Move ${func.name} up"
                                    title="Move up in order">
                                
                            </button>
                            <button onclick="moveFunctionDown(${index})" 
                                    ${index === functions.length - 1 ? 'disabled' : ''} 
                                    aria-label="Move ${func.name} down"
                                    title="Move down in order">
                                
                            </button>
                            <button class="edit-button" 
                                    onclick="startEditFunction(${index})" 
                                    aria-label="Rename ${func.name}"
                                    title="Rename this function">
                                Rename
                            </button>
                            ${functions.length > 1 ? `
                                <button class="remove-button" 
                                        onclick="removeFunction(${index})" 
                                        aria-label="Remove ${func.name} function"
                                        title="Remove this function">
                                    Remove
                                </button>
                            ` : ''}
                        ` : `
                            <button onclick="saveFunctionEdit(${index}, document.querySelector('.item-name-input').value)" 
                                    aria-label="Save changes"
                                    title="Save changes">
                                Save
                            </button>
                            <button onclick="cancelFunctionEdit(${index})" 
                                    aria-label="Cancel editing"
                                    title="Cancel editing">
                                Cancel
                            </button>
                        `}
                    </div>
                `;
                container.appendChild(item);
            });
        }
        
        /**
         * Render axis controls for both primary and secondary axes
         * Updates the axis configuration section in the sidebar
         */
        function renderAxisControls() {
            // Update axis control values from current configuration
            updateAxisControlValues();
            
            // Update axis control states (enable/disable inputs based on auto checkboxes)
            updateAxisControlStates();
        }
        
        /**
         * Update axis control input values from current configuration
         */
        function updateAxisControlValues() {
            // Primary axis controls
            const primaryMinInput = document.getElementById('primaryAxisMin');
            const primaryMaxInput = document.getElementById('primaryAxisMax');
            const primaryAutoMinCheck = document.getElementById('primaryAxisAutoMin');
            const primaryAutoMaxCheck = document.getElementById('primaryAxisAutoMax');
            
            if (primaryMinInput && primaryAutoMinCheck) {
                primaryMinInput.value = axisConfig.primary.min || '';
                primaryAutoMinCheck.checked = axisConfig.primary.autoMin;
            }
            
            if (primaryMaxInput && primaryAutoMaxCheck) {
                primaryMaxInput.value = axisConfig.primary.max || '';
                primaryAutoMaxCheck.checked = axisConfig.primary.autoMax;
            }
            
            // Secondary axis controls
            const secondaryMinInput = document.getElementById('secondaryAxisMin');
            const secondaryMaxInput = document.getElementById('secondaryAxisMax');
            const secondaryAutoMinCheck = document.getElementById('secondaryAxisAutoMin');
            const secondaryAutoMaxCheck = document.getElementById('secondaryAxisAutoMax');
            
            if (secondaryMinInput && secondaryAutoMinCheck) {
                secondaryMinInput.value = axisConfig.secondary.min !== null ? axisConfig.secondary.min : '';
                secondaryAutoMinCheck.checked = axisConfig.secondary.autoMin;
            }
            
            if (secondaryMaxInput && secondaryAutoMaxCheck) {
                secondaryMaxInput.value = axisConfig.secondary.max !== null ? axisConfig.secondary.max : '';
                secondaryAutoMaxCheck.checked = axisConfig.secondary.autoMax;
            }
        }
        
        /**
         * Update axis control states (enable/disable based on auto checkboxes)
         */
        function updateAxisControlStates() {
            // Primary axis
            const primaryMinInput = document.getElementById('primaryAxisMin');
            const primaryMaxInput = document.getElementById('primaryAxisMax');
            const primaryAutoMinCheck = document.getElementById('primaryAxisAutoMin');
            const primaryAutoMaxCheck = document.getElementById('primaryAxisAutoMax');
            
            if (primaryMinInput && primaryAutoMinCheck) {
                primaryMinInput.disabled = primaryAutoMinCheck.checked;
                primaryMinInput.style.opacity = primaryAutoMinCheck.checked ? '0.5' : '1';
            }
            
            if (primaryMaxInput && primaryAutoMaxCheck) {
                primaryMaxInput.disabled = primaryAutoMaxCheck.checked;
                primaryMaxInput.style.opacity = primaryAutoMaxCheck.checked ? '0.5' : '1';
            }
            
            // Secondary axis
            const secondaryMinInput = document.getElementById('secondaryAxisMin');
            const secondaryMaxInput = document.getElementById('secondaryAxisMax');
            const secondaryAutoMinCheck = document.getElementById('secondaryAxisAutoMin');
            const secondaryAutoMaxCheck = document.getElementById('secondaryAxisAutoMax');
            
            if (secondaryMinInput && secondaryAutoMinCheck) {
                secondaryMinInput.disabled = secondaryAutoMinCheck.checked;
                secondaryMinInput.style.opacity = secondaryAutoMinCheck.checked ? '0.5' : '1';
            }
            
            if (secondaryMaxInput && secondaryAutoMaxCheck) {
                secondaryMaxInput.disabled = secondaryAutoMaxCheck.checked;
                secondaryMaxInput.style.opacity = secondaryAutoMaxCheck.checked ? '0.5' : '1';
            }
        }
        
        /**
         * Render trend line configuration controls for each category
         * Creates individual controls for color, thickness, opacity, etc.
         */
        function renderTrendLineControls() {
            const container = document.getElementById('trendlineControls');
            if (!container) return;
            
            container.innerHTML = '';
            
            // Create header for trend line section
            const header = document.createElement('div');
            header.innerHTML = '<h4 style="margin: 0 0 15px 0; color: #333;">Individual Trend Line Settings</h4>';
            container.appendChild(header);
            
            categories.forEach((category, index) => {
                const config = trendLineConfig[category.id] || {};
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'trendline-category fade-in';
                categoryDiv.setAttribute('role', 'group');
                categoryDiv.setAttribute('aria-labelledby', `trendline-${category.id}-title`);
                
                categoryDiv.innerHTML = `
                    <div class="trendline-header">
                        <div class="trendline-color-indicator" 
                             style="background-color: ${category.color};"
                             title="Category color"></div>
                        <span class="trendline-name" id="trendline-${category.id}-title">${category.name}</span>
                        <div class="trendline-toggle">
                            <input type="checkbox" 
                                   id="trendline-${category.id}-enabled" 
                                   ${config.enabled ? 'checked' : ''}
                                   onchange="updateTrendLineConfig('${category.id}', 'enabled', this.checked)"
                                   aria-label="Enable trend line for ${category.name}">
                            <label for="trendline-${category.id}-enabled">Enable</label>
                        </div>
                    </div>
                    
                    <div class="trendline-controls-grid" id="trendline-${category.id}-controls" 
                         style="display: ${config.enabled ? 'grid' : 'none'};">
                        
                        <!-- Color Control -->
                        <div class="style-control">
                            <label for="trendline-${category.id}-color">Color:</label>
                            <input type="color" 
                                   id="trendline-${category.id}-color" 
                                   value="${config.color || category.color}"
                                   onchange="updateTrendLineConfig('${category.id}', 'color', this.value)"
                                   aria-label="Trend line color for ${category.name}">
                        </div>
                        
                        <!-- Thickness Control -->
                        <div class="style-control">
                            <label for="trendline-${category.id}-thickness">
                                Thickness: <span id="trendline-${category.id}-thickness-value">${config.thickness || 2}px</span>
                            </label>
                            <input type="range" 
                                   id="trendline-${category.id}-thickness" 
                                   min="1" max="8" value="${config.thickness || 2}"
                                   oninput="updateTrendLineThickness('${category.id}', this.value)"
                                   onchange="updateTrendLineConfig('${category.id}', 'thickness', parseInt(this.value))"
                                   aria-label="Trend line thickness for ${category.name}">
                        </div>
                        
                        <!-- Point Size Control -->
                        <div class="style-control">
                            <label for="trendline-${category.id}-pointsize">
                                Point Size: <span id="trendline-${category.id}-pointsize-value">${config.pointSize || 4}px</span>
                            </label>
                            <input type="range" 
                                   id="trendline-${category.id}-pointsize" 
                                   min="2" max="10" value="${config.pointSize || 4}"
                                   oninput="updateTrendLinePointSize('${category.id}', this.value)"
                                   onchange="updateTrendLineConfig('${category.id}', 'pointSize', parseInt(this.value))"
                                   aria-label="Trend line point size for ${category.name}">
                        </div>
                        
                        <!-- Opacity Control -->
                        <div class="style-control">
                            <label for="trendline-${category.id}-opacity">
                                Opacity: <span id="trendline-${category.id}-opacity-value">${Math.round((config.opacity || 1) * 100)}%</span>
                            </label>
                            <input type="range" 
                                   id="trendline-${category.id}-opacity" 
                                   min="10" max="100" value="${Math.round((config.opacity || 1) * 100)}"
                                   oninput="updateTrendLineOpacity('${category.id}', this.value)"
                                   onchange="updateTrendLineConfig('${category.id}', 'opacity', this.value / 100)"
                                   aria-label="Trend line opacity for ${category.name}">
                        </div>
                        
                        <!-- Show Points Toggle -->
                        <div class="style-control">
                            <div class="checkbox-item">
                                <input type="checkbox" 
                                       id="trendline-${category.id}-points" 
                                       ${config.showPoints !== false ? 'checked' : ''}
                                       onchange="updateTrendLineConfig('${category.id}', 'showPoints', this.checked)"
                                       aria-label="Show points for ${category.name} trend line">
                                <label for="trendline-${category.id}-points">Show Points</label>
                            </div>
                        </div>
                        
                        <!-- Show Line Toggle -->
                        <div class="style-control">
                            <div class="checkbox-item">
                                <input type="checkbox" 
                                       id="trendline-${category.id}-line" 
                                       ${config.showLine !== false ? 'checked' : ''}
                                       onchange="updateTrendLineConfig('${category.id}', 'showLine', this.checked)"
                                       aria-label="Show line for ${category.name} trend line">
                                <label for="trendline-${category.id}-line">Show Line</label>
                            </div>
                        </div>
                    </div>
                `;
                
                container.appendChild(categoryDiv);
            });
        }
        
        /**
         * Render data input forms for all functions with year and category breakdowns
         * Creates the main data entry interface
         */
        function renderDataInput() {
            const container = document.getElementById('dataInputContainer');
            if (!container) return;
            
            container.innerHTML = '<h3>Function Data Entry</h3>';
            
            functions.forEach(func => {
                const funcDiv = document.createElement('div');
                funcDiv.className = 'function-input fade-in';
                funcDiv.setAttribute('role', 'group');
                funcDiv.setAttribute('aria-labelledby', `${func.id}-title`);
                
                // Create category headers
                let categoryHeaders = '';
                categories.forEach(category => {
                    categoryHeaders += `<div class="category-header-item">${category.name}</div>`;
                });
                
                // Create year sections with input fields
                let yearSections = '';
                years.forEach(year => {
                    let categoryInputs = '';
                    categories.forEach((category, catIndex) => {
                        const value = getDataValue(func.id, year.id, catIndex);
                        categoryInputs += `
                            <input type="number" 
                                   id="${func.id}-${year.id}-${category.id}" 
                                   placeholder="${category.name}" 
                                   value="${value}" 
                                   min="0" 
                                   step="1"
                                   onchange="handleDataInput('${func.id}', '${year.id}', ${catIndex}, this.value)"
                                   oninput="validateNumericInput(this)"
                                   aria-label="${category.name} count for ${func.name} in ${year.name}">
                        `;
                    });
                    
                    yearSections += `
                        <div class="year-data">
                            <div class="year-label">${year.name} (${year.type})</div>
                            <div class="grade-inputs">${categoryInputs}</div>
                        </div>
                    `;
                });
                
                funcDiv.innerHTML = `
                    <h3 id="${func.id}-title">${func.name}</h3>
                    <div class="category-header">${categoryHeaders}</div>
                    ${yearSections}
                `;
                
                container.appendChild(funcDiv);
            });
        }
        
        /**
         * Update the legend display with current categories and years
         * Creates simplified legend showing unique categories (not split by year)
         */
        function updateLegend() {
            const container = document.getElementById('legendContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            // Create simplified legend - one entry per category (not per year)
            categories.forEach((category, index) => {
                const item = document.createElement('div');
                item.className = 'legend-item fade-in';
                item.setAttribute('role', 'listitem');
                item.setAttribute('tabindex', '0');
                item.setAttribute('aria-label', `${category.name} category data`);
                
                item.innerHTML = `
                    <div class="legend-color" 
                         style="background-color: ${category.color};"
                         title="${category.name} color"></div>
                    <span style="color: ${textStyles.categoryLabels.color}; 
                                 font-size: ${textStyles.categoryLabels.fontSize}px; 
                                 font-weight: ${textStyles.categoryLabels.fontWeight};">${category.name}</span>
                `;
                
                container.appendChild(item);
            });
        }
        
        /**
         * Update text style display values for all range sliders
         */
        function updateTextStyleDisplays() {
            // Data Labels
            const dataLabelSizeEl = document.getElementById('dataLabelFontSizeValue');
            if (dataLabelSizeEl) {
                dataLabelSizeEl.textContent = textStyles.dataLabels.fontSize + 'px';
            }
            
            // Axis Labels
            const axisLabelSizeEl = document.getElementById('axisLabelFontSizeValue');
            if (axisLabelSizeEl) {
                axisLabelSizeEl.textContent = textStyles.axisLabels.fontSize + 'px';
            }
            
            // Function Names
            const functionNameSizeEl = document.getElementById('functionNameFontSizeValue');
            if (functionNameSizeEl) {
                functionNameSizeEl.textContent = textStyles.functionNames.fontSize + 'px';
            }
            
            // Category Labels
            const categoryLabelSizeEl = document.getElementById('categoryLabelFontSizeValue');
            if (categoryLabelSizeEl) {
                categoryLabelSizeEl.textContent = textStyles.categoryLabels.fontSize + 'px';
            }
            
            // Update color inputs
            const dataLabelColorEl = document.getElementById('dataLabelColor');
            if (dataLabelColorEl) {
                dataLabelColorEl.value = textStyles.dataLabels.color;
            }
            
            const axisLabelColorEl = document.getElementById('axisLabelColor');
            if (axisLabelColorEl) {
                axisLabelColorEl.value = textStyles.axisLabels.color;
            }
            
            const functionNameColorEl = document.getElementById('functionNameColor');
            if (functionNameColorEl) {
                functionNameColorEl.value = textStyles.functionNames.color;
            }
            
            const categoryLabelColorEl = document.getElementById('categoryLabelColor');
            if (categoryLabelColorEl) {
                categoryLabelColorEl.value = textStyles.categoryLabels.color;
            }
            
            // Update weight selects
            const dataLabelWeightEl = document.getElementById('dataLabelWeight');
            if (dataLabelWeightEl) {
                dataLabelWeightEl.value = textStyles.dataLabels.fontWeight;
            }
            
            const functionNameWeightEl = document.getElementById('functionNameWeight');
            if (functionNameWeightEl) {
                functionNameWeightEl.value = textStyles.functionNames.fontWeight;
            }
            
            const categoryLabelWeightEl = document.getElementById('categoryLabelWeight');
            if (categoryLabelWeightEl) {
                categoryLabelWeightEl.value = textStyles.categoryLabels.fontWeight;
            }
        }
        
        /**
         * Update shading preview boxes when opacity settings change
         */
        function updateShadingPreview() {
            const prevPreview = document.getElementById('prevPreview');
            const currPreview = document.getElementById('currPreview');
            
            if (prevPreview && currPreview) {
                const prevOpacity = getOpacity('previous');
                const currOpacity = getOpacity('current');
                
                // Use first category color for preview
                const baseColor = categories[0]?.color || '#4CAF50';
                
                prevPreview.style.backgroundColor = baseColor + prevOpacity;
                currPreview.style.backgroundColor = baseColor + currOpacity;
            }
        }
        
        /**
         * Update chart spacing controls display
         */
        function updateSpacingControls() {
            const columnSpacingEl = document.getElementById('columnSpacing');
            const categoryGapEl = document.getElementById('categoryGap');
            
            if (columnSpacingEl) {
                columnSpacingEl.value = columnSpacing;
                document.getElementById('columnSpacingValue').textContent = columnSpacing;
            }
            
            if (categoryGapEl) {
                categoryGapEl.value = categoryGap;
                document.getElementById('categoryGapValue').textContent = categoryGap;
            }
        }
        
        /**
         * Toggle data label options visibility based on main checkbox
         */
        function toggleDataLabelOptions() {
            const showDataLabels = document.getElementById('showDataLabels')?.checked || false;
            const options = document.getElementById('dataLabelOptions');
            
            if (options) {
                options.style.display = showDataLabels ? 'grid' : 'none';
                options.setAttribute('aria-hidden', showDataLabels ? 'false' : 'true');
            }
        }
        
        /**
         * Toggle manual opacity controls based on shading mode
         */
        function toggleManualOpacityControls() {
            const shadingMode = document.querySelector('input[name="shading"]:checked')?.value || 'auto';
            const manualControls = document.getElementById('manualOpacityControls');
            
            if (manualControls) {
                manualControls.style.display = shadingMode === 'manual' ? 'block' : 'none';
            }
        }
        
        /**
         * Update trend line display values (thickness, point size, opacity)
         * @param {string} categoryId - Category identifier
         * @param {string} property - Property being updated
         * @param {string} value - New value
         */
        function updateTrendLineDisplayValue(categoryId, property, value) {
            let displayElementId = '';
            let displayValue = '';
            
            switch (property) {
                case 'thickness':
                    displayElementId = `trendline-${categoryId}-thickness-value`;
                    displayValue = value + 'px';
                    break;
                case 'pointSize':
                    displayElementId = `trendline-${categoryId}-pointsize-value`;
                    displayValue = value + 'px';
                    break;
                case 'opacity':
                    displayElementId = `trendline-${categoryId}-opacity-value`;
                    displayValue = value + '%';
                    break;
            }
            
            const displayEl = document.getElementById(displayElementId);
            if (displayEl) {
                displayEl.textContent = displayValue;
            }
        }
        
        /**
         * Handle keyboard events during inline editing
         * @param {Event} event - Keyboard event
         * @param {number} index - Index of item being edited
         * @param {string} type - Type of item ('function', 'category', 'year')
         * @param {string} value - Current input value
         */
        function handleEditKeydown(event, index, type, value) {
            if (event.key === 'Enter') {
                event.preventDefault();
                switch (type) {
                    case 'function':
                        saveFunctionEdit(index, value);
                        break;
                    case 'category':
                        saveCategoryEdit(index, value);
                        break;
                    case 'year':
                        saveYearEdit(index, value);
                        break;
                }
            } else if (event.key === 'Escape') {
                event.preventDefault();
                switch (type) {
                    case 'function':
                        cancelFunctionEdit(index);
                        break;
                    case 'category':
                        cancelCategoryEdit(index);
                        break;
                    case 'year':
                        cancelYearEdit(index);
                        break;
                }
            }
        }
        
        /**
         * Announce changes to screen readers
         * @param {string} message - Message to announce
         */
        function announceChange(message) {
            const announcement = document.getElementById('announcement');
            if (announcement) {
                announcement.textContent = message;
                
                // Clear after a delay to allow for multiple announcements
                setTimeout(() => {
                    if (announcement.textContent === message) {
                        announcement.textContent = '';
                    }
                }, 1000);
            }
        }
        
        /**
         * Validate numeric input fields to ensure only positive integers
         * @param {HTMLInputElement} input - Input element to validate
         */
        function validateNumericInput(input) {
            let value = input.value;
            
            // Remove any non-numeric characters except decimal point
            value = value.replace(/[^\d]/g, '');
            
            // Ensure value is not negative
            if (parseInt(value) < 0) {
                value = '0';
            }
            
            input.value = value;
        }
        
        /**
         * Create and manage loading states for UI elements
         * @param {HTMLElement} element - Element to show loading state on
         * @param {boolean} show - Whether to show or hide loading state
         */
        function toggleLoadingState(element, show) {
            if (!element) return;
            
            if (show) {
                element.classList.add('loading');
                element.setAttribute('aria-busy', 'true');
            } else {
                element.classList.remove('loading');
                element.setAttribute('aria-busy', 'false');
            }
        }
        
        /**
         * Update progress indicators during long operations
         * @param {string} containerId - ID of container to show progress in
         * @param {number} percentage - Progress percentage (0-100)
         * @param {string} message - Progress message
         */
        function updateProgress(containerId, percentage, message) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            let progressBar = container.querySelector('.progress-bar');
            if (!progressBar) {
                progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                progressBar.innerHTML = `
                    <div class="progress-fill" style="width: 0%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); height: 4px; border-radius: 2px; transition: width 0.3s ease;"></div>
                    <div class="progress-text" style="font-size: 12px; color: #666; margin-top: 5px;"></div>
                `;
                container.appendChild(progressBar);
            }
            
            const fill = progressBar.querySelector('.progress-fill');
            const text = progressBar.querySelector('.progress-text');
            
            if (fill) fill.style.width = percentage + '%';
            if (text) text.textContent = message;
            
            // Remove progress bar when complete
            if (percentage >= 100) {
                setTimeout(() => {
                    if (progressBar.parentElement) {
                        progressBar.remove();
                    }
                }, 1000);
            }
        }
        
        /**
         * Create and show toast notifications
         * @param {string} message - Notification message
         * @param {string} type - Notification type ('success', 'error', 'warning', 'info')
         * @param {number} duration - Duration in milliseconds (default: 3000)
         */
        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type} fade-in`;
            
            const colors = {
                success: '#4CAF50',
                error: '#f44336',
                warning: '#ff9800',
                info: '#2196F3'
            };
            
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${colors[type] || colors.info};
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                z-index: 10000;
                max-width: 400px;
                font-weight: 500;
                animation: slideInRight 0.3s ease;
            `;
            
            toast.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span>${message}</span>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: none; border: none; color: white; font-size: 18px; cursor: pointer; padding: 0; margin-left: 10px;"
                            aria-label="Close notification"></button>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // Auto-remove after specified duration
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.style.animation = 'slideOutRight 0.3s ease';
                    setTimeout(() => toast.remove(), 300);
                }
            }, duration);
            
            // Announce to screen readers
            announceChange(message);
        }
        
        /**
         * Render all UI components in the correct order
         * Main function to update the entire interface
         */
        function renderAllComponents() {
            try {
                // Show loading state
                const sidebar = document.querySelector('.sidebar');
                toggleLoadingState(sidebar, true);
                
                // Render all components
                renderYears();
                renderCategories();
                renderFunctions();
                renderAxisControls();
                renderTrendLineControls();
                renderDataInput();
                
                // Update displays
                updateLegend();
                updateTextStyleDisplays();
                updateShadingPreview();
                updateSpacingControls();
                toggleDataLabelOptions();
                toggleManualOpacityControls();
                
                // Hide loading state
                toggleLoadingState(sidebar, false);
                
                console.log('All UI components rendered successfully');
                
            } catch (error) {
                console.error('Error rendering UI components:', error);
                showToast('Error updating interface', 'error');
                
                // Hide loading state even on error
                const sidebar = document.querySelector('.sidebar');
                toggleLoadingState(sidebar, false);
            }
        }
        
        /**
         * Debounce function to limit how often a function can be called
         * @param {Function} func - Function to debounce
         * @param {number} wait - Wait time in milliseconds
         * @returns {Function} Debounced function
         */
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        /**
         * Throttle function to limit function calls to once per interval
         * @param {Function} func - Function to throttle
         * @param {number} limit - Time limit in milliseconds
         * @returns {Function} Throttled function
         */
        function throttle(func, limit) {
            let inThrottle;
            return function() {
                const args = arguments;
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }
        
        /**
         * Create debounced chart update function
         */
        const debouncedChartUpdate = debounce(() => {
            if (typeof createCharts === 'function') {
                createCharts();
            }
        }, UPDATE_DELAY);
        
        /**
         * Create throttled render function for high-frequency updates
         */
        const throttledRender = throttle(renderAllComponents, 100);
        
        /**
         * Handle data input changes with validation and chart updates
         * @param {string} functionId - Function identifier
         * @param {string} yearId - Year identifier
         * @param {number} categoryIndex - Category index
         * @param {string} value - Input value from form field
         */
        function handleDataInput(functionId, yearId, categoryIndex, value) {
            const numValue = parseInt(value) || 0;
            
            if (setDataValue(functionId, yearId, categoryIndex, numValue)) {
                // Clear existing timeout
                if (updateTimeout) {
                    clearTimeout(updateTimeout);
                }
                
                // Throttle chart updates to improve performance
                updateTimeout = setTimeout(() => {
                    debouncedChartUpdate();
                    
                    const categoryName = categories[categoryIndex]?.name || 'data';
                    const functionName = getFunctionById(functionId)?.name || 'function';
                    announceChange(`Updated ${categoryName} for ${functionName}`);
                }, UPDATE_DELAY);
            } else {
                showToast('Invalid data input', 'error');
            }
        }
        
        /**
         * Focus management for accessibility
         * @param {HTMLElement} element - Element to focus
         * @param {number} delay - Delay before focusing (default: 0)
         */
        function manageFocus(element, delay = 0) {
            if (!element) return;
            
            setTimeout(() => {
                if (element && typeof element.focus === 'function') {
                    element.focus();
                    
                    // Scroll into view if needed
                    if (typeof element.scrollIntoView === 'function') {
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            }, delay);
        }
        
        /**
         * Setup intersection observer for fade-in animations
         */
        function setupIntersectionObserver() {
            const observerOptions = {
                threshold: 0.1,
                rootMargin: '0px 0px -50px 0px'
            };
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('fade-in');
                        observer.unobserve(entry.target);
                    }
                });
            }, observerOptions);
            
            // Observe all elements that should fade in
            document.querySelectorAll('.function-input, .chart-container, .trend-container').forEach(el => {
                observer.observe(el);
            });
        }
        
        /**
         * Initialize UI components and event listeners
         */
        function initializeUI() {
            try {
                console.log('Initializing UI components...');
                
                // Render all components
                renderAllComponents();
                
                // Setup animations if supported
                if ('IntersectionObserver' in window) {
                    setupIntersectionObserver();
                }
                
                // Setup accessibility announcements
                if (!document.getElementById('announcement')) {
                    const announcement = document.createElement('div');
                    announcement.id = 'announcement';
                    announcement.className = 'sr-only';
                    announcement.setAttribute('aria-live', 'polite');
                    announcement.setAttribute('aria-atomic', 'true');
                    document.body.appendChild(announcement);
                }
                
                console.log('UI initialization complete');
                announceChange('Dashboard interface ready');
                
            } catch (error) {
                console.error('Error initializing UI:', error);
                showToast('Error initializing interface', 'error');
            }
        }
        
        /**
         * Cleanup UI resources and event listeners
         */
        function cleanupUI() {
            // Clear any pending timeouts
            if (updateTimeout) {
                clearTimeout(updateTimeout);
                updateTimeout = null;
            }
            
            // Remove any temporary elements
            document.querySelectorAll('.toast, .progress-bar').forEach(el => el.remove());
            
            // Cancel any edit modes
            cancelAllEditModes();
            
            console.log('UI cleanup completed');
        }
        
        /**
         * Handle UI errors gracefully
         * @param {Error} error - Error object
         * @param {string} context - Context where error occurred
         */
        function handleUIError(error, context = 'UI operation') {
            console.error(`Error in ${context}:`, error);
            
            // Show user-friendly error message
            showToast(`Error in ${context}. Please try again.`, 'error');
            
            // Clear any loading states
            document.querySelectorAll('.loading').forEach(el => {
                toggleLoadingState(el, false);
            });
            
            // Announce error to screen readers
            announceChange(`Error occurred in ${context}`);
        }
        
        /**
         * Export UI state for debugging
         * @returns {Object} Current UI state
         */
        function getUIState() {
            return {
                editModes: {
                    functions: functions.map(f => f.editable),
                    categories: categories.map(c => c.editable),
                    years: years.map(y => y.editable)
                },
                controlStates: {
                    showDataLabels: document.getElementById('showDataLabels')?.checked,
                    showValues: document.getElementById('showValues')?.checked,
                    showPercentages: document.getElementById('showPercentages')?.checked,
                    showTrendLine: document.getElementById('showTrendLine')?.checked,
                    chartType: document.getElementById('chartType')?.value,
                    animation: document.getElementById('animation')?.value,
                    sortBy: document.getElementById('sortBy')?.value,
                    sortDirection: document.getElementById('sortDirection')?.value
                },
                axisStates: {
                    primaryAutoMin: document.getElementById('primaryAxisAutoMin')?.checked,
                    primaryAutoMax: document.getElementById('primaryAxisAutoMax')?.checked,
                    secondaryAutoMin: document.getElementById('secondaryAxisAutoMin')?.checked,
                    secondaryAutoMax: document.getElementById('secondaryAxisAutoMax')?.checked
                }
            };
        }
        
        /**
         * Restore UI state from saved data
         * @param {Object} state - Saved UI state
         */
        function restoreUIState(state) {
            if (!state) return;
            
            try {
                // Restore control states
                if (state.controlStates) {
                    Object.entries(state.controlStates).forEach(([key, value]) => {
                        const element = document.getElementById(key);
                        if (element) {
                            if (element.type === 'checkbox') {
                                element.checked = value;
                            } else {
                                element.value = value;
                            }
                        }
                    });
                }
                
                // Restore axis states
                if (state.axisStates) {
                    Object.entries(state.axisStates).forEach(([key, value]) => {
                        const element = document.getElementById(key);
                        if (element && element.type === 'checkbox') {
                            element.checked = value;
                        }
                    });
                }
                
                // Update UI to reflect restored state
                toggleDataLabelOptions();
                toggleManualOpacityControls();
                updateAxisControlStates();
                
                console.log('UI state restored successfully');
                
            } catch (error) {
                console.error('Error restoring UI state:', error);
                showToast('Error restoring interface state', 'error');
            }
        }
        
        /**
         * Update responsive elements based on screen size
         */
        function updateResponsiveElements() {
            const windowWidth = window.innerWidth;
            
            // Adjust layout based on screen size
            if (windowWidth < 768) {
                // Mobile layout adjustments
                adjustMobileLayout();
            } else if (windowWidth < 992) {
                // Tablet layout adjustments
                adjustTabletLayout();
            } else {
                // Desktop layout adjustments
                adjustDesktopLayout();
            }
        }
        
        /**
         * Adjust layout for mobile devices
         */
        function adjustMobileLayout() {
            const dashboard = document.getElementById('dashboardGrid');
            if (dashboard) {
                dashboard.style.gridTemplateColumns = '1fr';
            }
            
            // Stack controls vertically on mobile
            const controls = document.querySelector('.controls');
            if (controls) {
                controls.style.gridTemplateColumns = '1fr';
            }
        }
        
        /**
         * Adjust layout for tablet devices
         */
        function adjustTabletLayout() {
            const dashboard = document.getElementById('dashboardGrid');
            if (dashboard) {
                dashboard.style.gridTemplateColumns = '1fr';
            }
            
            // Use 2-column layout for controls on tablet
            const controls = document.querySelector('.controls');
            if (controls) {
                controls.style.gridTemplateColumns = 'repeat(auto-fit, minmax(120px, 1fr))';
            }
        }
        
        /**
         * Adjust layout for desktop devices
         */
        function adjustDesktopLayout() {
            const dashboard = document.getElementById('dashboardGrid');
            if (dashboard) {
                dashboard.style.gridTemplateColumns = '1fr 400px';
            }
            
            // Use multi-column layout for controls on desktop
            const controls = document.querySelector('.controls');
            if (controls) {
                controls.style.gridTemplateColumns = 'repeat(auto-fit, minmax(150px, 1fr))';
            }
        }
        
        /**
         * Create smooth transitions for UI state changes
         * @param {HTMLElement} element - Element to animate
         * @param {string} property - CSS property to animate
         * @param {string} fromValue - Starting value
         * @param {string} toValue - Ending value
         * @param {number} duration - Animation duration in milliseconds
         */
        function animateProperty(element, property, fromValue, toValue, duration = 300) {
            if (!element) return;
            
            const startTime = performance.now();
            const startValue = parseFloat(fromValue);
            const endValue = parseFloat(toValue);
            const difference = endValue - startValue;
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easing function for smooth animation
                const easeInOut = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                const currentValue = startValue + (difference * easeInOut);
                element.style[property] = currentValue + (property.includes('opacity') ? '' : 'px');
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        /**
         * Add CSS animation classes dynamically
         * @param {HTMLElement} element - Element to animate
         * @param {string} animationClass - CSS animation class to add
         * @param {Function} onComplete - Callback when animation completes
         */
        function addAnimation(element, animationClass, onComplete) {
            if (!element) return;
            
            element.classList.add(animationClass);
            
            const handleAnimationEnd = () => {
                element.classList.remove(animationClass);
                element.removeEventListener('animationend', handleAnimationEnd);
                if (onComplete) onComplete();
            };
            
            element.addEventListener('animationend', handleAnimationEnd);
        }
        
        /* ===========================================
           END OF PART 3: UI RENDERING & DOM MANAGEMENT
           =========================================== */
        /* ===========================================
           PART 4: EVENT HANDLERS & USER INTERACTIONS
           =========================================== */
        
        // ===== EVENT HANDLER SETUP =====
        
        /**
         * Initialize all event listeners for the application
         */
        function initializeEventListeners() {
            console.log('Setting up event listeners...');
            
            // Text styling controls
            setupTextStyleEventListeners();
            
            // Axis control event listeners
            setupAxisControlEventListeners();
            
            // Chart control event listeners
            setupChartControlEventListeners();
            
            // Data label and trend line event listeners
            setupDataLabelEventListeners();
            
            // Shading control event listeners
            setupShadingEventListeners();
            
            // Spacing control event listeners
            setupSpacingEventListeners();
            
            // Keyboard shortcuts and global events
            setupGlobalEventListeners();
            
            // Window and resize events
            setupWindowEventListeners();
            
            console.log('Event listeners setup complete');
        }
        
        // ===== TEXT STYLING EVENT LISTENERS =====
        
        /**
         * Setup event listeners for text styling controls
         */
        function setupTextStyleEventListeners() {
            // Font size range sliders
            document.addEventListener('input', function(e) {
                // Data label font size
                if (e.target.id === 'dataLabelFontSize') {
                    updateTextStyle('dataLabels', 'fontSize', parseInt(e.target.value));
                }
                // Axis label font size
                else if (e.target.id === 'axisLabelFontSize') {
                    updateTextStyle('axisLabels', 'fontSize', parseInt(e.target.value));
                }
                // Function name font size
                else if (e.target.id === 'functionNameFontSize') {
                    updateTextStyle('functionNames', 'fontSize', parseInt(e.target.value));
                }
                // Category label font size
                else if (e.target.id === 'categoryLabelFontSize') {
                    updateTextStyle('categoryLabels', 'fontSize', parseInt(e.target.value));
                }
            });
            
            // Color picker changes
            document.addEventListener('change', function(e) {
                // Text styling colors
                if (e.target.id === 'dataLabelColor') {
                    updateTextStyle('dataLabels', 'color', e.target.value);
                }
                else if (e.target.id === 'axisLabelColor') {
                    updateTextStyle('axisLabels', 'color', e.target.value);
                }
                else if (e.target.id === 'functionNameColor') {
                    updateTextStyle('functionNames', 'color', e.target.value);
                }
                else if (e.target.id === 'categoryLabelColor') {
                    updateTextStyle('categoryLabels', 'color', e.target.value);
                }
                // Text styling weights
                else if (e.target.id === 'dataLabelWeight') {
                    updateTextStyle('dataLabels', 'fontWeight', e.target.value);
                }
                else if (e.target.id === 'functionNameWeight') {
                    updateTextStyle('functionNames', 'fontWeight', e.target.value);
                }
                else if (e.target.id === 'categoryLabelWeight') {
                    updateTextStyle('categoryLabels', 'fontWeight', e.target.value);
                }
            });
        }
        
        /**
         * Update text style configuration and refresh charts
         * @param {string} element - Text element type (dataLabels, axisLabels, etc.)
         * @param {string} property - Style property (fontSize, color, fontWeight)
         * @param {*} value - New value for the property
         */
        function updateTextStyle(element, property, value) {
            if (!textStyles[element]) {
                textStyles[element] = {};
            }
            
            textStyles[element][property] = value;
            
            // Update display values for range sliders
            updateTextStyleDisplays();
            
            // Recreate charts with new styling
            debouncedChartUpdate();
            
            announceChange(`Updated ${element} ${property}`);
        }
        
        // ===== AXIS CONTROL EVENT LISTENERS =====
        
        /**
         * Setup event listeners for axis controls
         */
        function setupAxisControlEventListeners() {
            // Primary axis controls
            document.addEventListener('change', function(e) {
                if (e.target.id === 'primaryAxisMin') {
                    updateAxisConfig('primary', 'min', parseFloat(e.target.value) || null);
                    debouncedChartUpdate();
                }
                else if (e.target.id === 'primaryAxisMax') {
                    updateAxisConfig('primary', 'max', parseFloat(e.target.value) || null);
                    debouncedChartUpdate();
                }
                else if (e.target.id === 'primaryAxisAutoMin') {
                    updateAxisConfig('primary', 'autoMin', e.target.checked);
                    updateAxisControlStates();
                    debouncedChartUpdate();
                }
                else if (e.target.id === 'primaryAxisAutoMax') {
                    updateAxisConfig('primary', 'autoMax', e.target.checked);
                    updateAxisControlStates();
                    debouncedChartUpdate();
                }
                // Secondary axis controls
                else if (e.target.id === 'secondaryAxisMin') {
                    updateAxisConfig('secondary', 'min', parseFloat(e.target.value) || null);
                    debouncedChartUpdate();
                }
                else if (e.target.id === 'secondaryAxisMax') {
                    updateAxisConfig('secondary', 'max', parseFloat(e.target.value) || null);
                    debouncedChartUpdate();
                }
                else if (e.target.id === 'secondaryAxisAutoMin') {
                    updateAxisConfig('secondary', 'autoMin', e.target.checked);
                    updateAxisControlStates();
                    debouncedChartUpdate();
                }
                else if (e.target.id === 'secondaryAxisAutoMax') {
                    updateAxisConfig('secondary', 'autoMax', e.target.checked);
                    updateAxisControlStates();
                    debouncedChartUpdate();
                }
            });
        }
        
        // ===== CHART CONTROL EVENT LISTENERS =====
        
        /**
         * Setup event listeners for chart controls
         */
        function setupChartControlEventListeners() {
            document.addEventListener('change', function(e) {
                // Chart controls that trigger chart recreation
                if (['chartType', 'animation', 'sortBy', 'sortDirection'].includes(e.target.id)) {
                    debouncedChartUpdate();
                    announceChange(`Changed ${e.target.id} to ${e.target.value}`);
                }
            });
        }
        
        // ===== DATA LABEL EVENT LISTENERS =====
        
        /**
         * Setup event listeners for data label controls
         */
        function setupDataLabelEventListeners() {
            document.addEventListener('change', function(e) {
                // Data label checkboxes
                if (['showDataLabels', 'showValues', 'showPercentages', 'showTrendLine'].includes(e.target.id)) {
                    if (e.target.id === 'showDataLabels') {
                        toggleDataLabelOptions();
                    }
                    debouncedChartUpdate();
                    announceChange(`${e.target.checked ? 'Enabled' : 'Disabled'} ${e.target.id.replace(/([A-Z])/g, ' $1').toLowerCase()}`);
                }
            });
        }
        
        // ===== SHADING CONTROL EVENT LISTENERS =====
        
        /**
         * Setup event listeners for shading controls
         */
        function setupShadingEventListeners() {
            // Shading mode changes
            document.addEventListener('change', function(e) {
                if (e.target.name === 'shading') {
                    toggleManualOpacityControls();
                    updateShadingPreview();
                    debouncedChartUpdate();
                    announceChange(`Changed shading to ${e.target.value} mode`);
                }
            });
            
            // Opacity slider changes
            document.addEventListener('input', function(e) {
                if (e.target.id === 'prevOpacity' || e.target.id === 'currOpacity') {
                    const isPrevoius = e.target.id === 'prevOpacity';
                    const valueEl = document.getElementById(isPrevoius ? 'prevOpacityValue' : 'currOpacityValue');
                    if (valueEl) valueEl.textContent = e.target.value + '%';
                    updateShadingPreview();
                }
            });
            
            document.addEventListener('change', function(e) {
                if (e.target.id === 'prevOpacity' || e.target.id === 'currOpacity') {
                    updateShadingPreview();
                    debouncedChartUpdate();
                }
            });
        }
        
        // ===== SPACING CONTROL EVENT LISTENERS =====
        
        /**
         * Setup event listeners for spacing controls
         */
        function setupSpacingEventListeners() {
            document.addEventListener('input', function(e) {
                // Chart spacing controls
                if (e.target.id === 'columnSpacing' || e.target.id === 'categoryGap') {
                    updateSpacing();
                }
            });
        }
        
        /**
         * Update chart spacing and recreate charts
         */
        function updateSpacing() {
            const columnSpacingEl = document.getElementById('columnSpacing');
            const categoryGapEl = document.getElementById('categoryGap');
            
            if (columnSpacingEl) {
                columnSpacing = parseInt(columnSpacingEl.value);
                document.getElementById('columnSpacingValue').textContent = columnSpacing;
            }
            
            if (categoryGapEl) {
                categoryGap = parseInt(categoryGapEl.value);
                document.getElementById('categoryGapValue').textContent = categoryGap;
            }
            
            debouncedChartUpdate();
        }
        
        // ===== TREND LINE EVENT HANDLERS =====
        
        /**
         * Update trend line configuration for a specific category
         * @param {string} categoryId - Category identifier
         * @param {string} property - Property to update
         * @param {*} value - New value
         */
        function updateTrendLineConfig(categoryId, property, value) {
            if (!trendLineConfig[categoryId]) {
                trendLineConfig[categoryId] = {};
            }
            
            trendLineConfig[categoryId][property] = value;
            
            // Toggle controls visibility when enabled/disabled
            if (property === 'enabled') {
                const controlsEl = document.getElementById(`trendline-${categoryId}-controls`);
                if (controlsEl) {
                    controlsEl.style.display = value ? 'grid' : 'none';
                }
                announceChange(`${value ? 'Enabled' : 'Disabled'} trend line for ${getCategoryById(categoryId)?.name}`);
            }
            
            // Recreate charts with new trend line configuration
            debouncedChartUpdate();
        }
        
        /**
         * Update trend line thickness display and configuration
         * @param {string} categoryId - Category identifier
         * @param {string} value - Thickness value
         */
        function updateTrendLineThickness(categoryId, value) {
            updateTrendLineDisplayValue(categoryId, 'thickness', value);
        }
        
        /**
         * Update trend line point size display and configuration
         * @param {string} categoryId - Category identifier
         * @param {string} value - Point size value
         */
        function updateTrendLinePointSize(categoryId, value) {
            updateTrendLineDisplayValue(categoryId, 'pointSize', value);
        }
        
        /**
         * Update trend line opacity display and configuration
         * @param {string} categoryId - Category identifier
         * @param {string} value - Opacity value (0-100)
         */
        function updateTrendLineOpacity(categoryId, value) {
            updateTrendLineDisplayValue(categoryId, 'opacity', value);
        }
        
        // ===== YEARS MANAGEMENT EVENT HANDLERS =====
        
        /**
         * Add a new year to the configuration
         */
        function addYear() {
            const nameInput = document.getElementById('newYearName');
            const typeSelect = document.getElementById('yearType');
            
            if (!nameInput || !typeSelect) return;
            
            const name = nameInput.value.trim();
            const type = typeSelect.value;
            
            if (!name) {
                showToast('Please enter a year name', 'warning');
                manageFocus(nameInput);
                return;
            }
            
            // Check for duplicate year names
            if (!validateUniqueName(name, years)) {
                showToast('Year name already exists', 'error');
                manageFocus(nameInput);
                return;
            }
            
            // Add year using data management function
            const newYear = addYearToData(name, type);
            if (newYear) {
                // Clear input and update UI
                nameInput.value = '';
                renderYears();
                renderDataInput();
                debouncedChartUpdate();
                showToast(`Added ${name} as ${type} year`, 'success');
                announceChange(`Added ${name} as ${type} year`);
            } else {
                showToast('Failed to add year', 'error');
            }
        }
        
        /**
         * Remove a year from the configuration
         * @param {number} index - Index of year to remove
         */
        function removeYear(index) {
            if (years.length <= 1) {
                showToast('Cannot remove the last year', 'warning');
                return;
            }
            
            const year = years[index];
            const yearName = year.name;
            
            if (removeYearFromData(index)) {
                renderYears();
                renderDataInput();
                debouncedChartUpdate();
                showToast(`Removed ${yearName}`, 'success');
                announceChange(`Removed ${yearName}`);
            } else {
                showToast('Failed to remove year', 'error');
            }
        }
        
        /**
         * Toggle year type between previous and current
         * @param {number} index - Index of year to toggle
         */
        function toggleYearType(index) {
            const year = years[index];
            const newType = year.type === 'previous' ? 'current' : 'previous';
            
            // If changing to a type that already exists, swap them
            const existingTypeIndex = years.findIndex(y => y.type === newType);
            if (existingTypeIndex !== -1 && existingTypeIndex !== index) {
                years[existingTypeIndex].type = year.type;
            }
            
            year.type = newType;
            
            renderYears();
            renderDataInput();
            debouncedChartUpdate();
            showToast(`Changed ${year.name} to ${newType} year`, 'success');
            announceChange(`Changed ${year.name} to ${newType} year`);
        }
        
        /**
         * Start editing a year name
         * @param {number} index - Index of year to edit
         */
        function startEditYear(index) {
            if (startEditYear(index)) {
                renderYears();
                // Focus will be handled by autofocus in the input
            }
        }
        
        /**
         * Save year name edit
         * @param {number} index - Index of year being edited
         * @param {string} newName - New name for the year
         */
        function saveYearEdit(index, newName) {
            if (saveYearEdit(index, newName)) {
                renderYears();
                renderDataInput();
                debouncedChartUpdate();
                showToast('Year renamed successfully', 'success');
                announceChange(`Renamed year to ${newName}`);
            } else {
                showToast('Invalid name or name already exists', 'error');
                // Re-render to show original name
                renderYears();
            }
        }
        
        /**
         * Cancel year name edit
         * @param {number} index - Index of year to cancel edit
         */
        function cancelYearEdit(index) {
            if (cancelYearEdit(index)) {
                renderYears();
            }
        }
        
        // ===== CATEGORIES MANAGEMENT EVENT HANDLERS =====
        
        /**
         * Add a new category to the configuration
         */
        function addCategory() {
            const nameInput = document.getElementById('newCategoryName');
            const colorInput = document.getElementById('newCategoryColor');
            
            if (!nameInput || !colorInput) return;
            
            const name = nameInput.value.trim();
            const color = colorInput.value;
            
            if (!name) {
                showToast('Please enter a category name', 'warning');
                manageFocus(nameInput);
                return;
            }
            
            // Check for duplicate category names
            if (!validateUniqueName(name, categories)) {
                showToast('Category name already exists', 'error');
                manageFocus(nameInput);
                return;
            }
            
            // Add category using data management function
            const newCategory = addCategoryToData(name, color);
            if (newCategory) {
                // Clear input and update UI
                nameInput.value = '';
                colorInput.value = '#2196F3';
                renderCategories();
                renderDataInput();
                renderTrendLineControls();
                debouncedChartUpdate();
                showToast(`Added ${name} category`, 'success');
                announceChange(`Added ${name} category`);
            } else {
                showToast('Failed to add category', 'error');
            }
        }
        
        /**
         * Remove a category from the configuration
         * @param {number} index - Index of category to remove
         */
        function removeCategory(index) {
            if (categories.length <= 1) {
                showToast('Cannot remove the last category', 'warning');
                return;
            }
            
            const category = categories[index];
            const categoryName = category.name;
            
            if (removeCategoryFromData(index)) {
                renderCategories();
                renderDataInput();
                renderTrendLineControls();
                debouncedChartUpdate();
                showToast(`Removed ${categoryName} category`, 'success');
                announceChange(`Removed ${categoryName} category`);
            } else {
                showToast('Failed to remove category', 'error');
            }
        }
        
        /**
         * Start editing a category name
         * @param {number} index - Index of category to edit
         */
        function startEditCategory(index) {
            if (startEditCategory(index)) {
                renderCategories();
                // Focus will be handled by autofocus in the input
            }
        }
        
        /**
         * Save category name edit
         * @param {number} index - Index of category being edited
         * @param {string} newName - New name for the category
         */
        function saveCategoryEdit(index, newName) {
            if (saveCategoryEdit(index, newName)) {
                renderCategories();
                renderDataInput();
                renderTrendLineControls();
                updateLegend();
                debouncedChartUpdate();
                showToast('Category renamed successfully', 'success');
                announceChange(`Renamed category to ${newName}`);
            } else {
                showToast('Invalid name or name already exists', 'error');
                // Re-render to show original name
                renderCategories();
            }
        }
        
        /**
         * Cancel category name edit
         * @param {number} index - Index of category to cancel edit
         */
        function cancelCategoryEdit(index) {
            if (cancelCategoryEdit(index)) {
                renderCategories();
            }
        }
        
        // ===== FUNCTIONS MANAGEMENT EVENT HANDLERS =====
        
        /**
         * Add a new function to the configuration
         */
        function addFunction() {
            const nameInput = document.getElementById('newFunctionName');
            
            if (!nameInput) return;
            
            const name = nameInput.value.trim();
            
            if (!name) {
                showToast('Please enter a function name', 'warning');
                manageFocus(nameInput);
                return;
            }
            
            // Check for duplicate function names
            if (!validateUniqueName(name, functions)) {
                showToast('Function name already exists', 'error');
                manageFocus(nameInput);
                return;
            }
            
            // Add function using data management function
            const newFunction = addFunctionToData(name);
            if (newFunction) {
                // Clear input and update UI
                nameInput.value = '';
                renderFunctions();
                renderDataInput();
                debouncedChartUpdate();
                showToast(`Added ${name} function`, 'success');
                announceChange(`Added ${name} function`);
            } else {
                showToast('Failed to add function', 'error');
            }
        }
        
        /**
         * Remove a function from the configuration
         * @param {number} index - Index of function to remove
         */
        function removeFunction(index) {
            if (functions.length <= 1) {
                showToast('Cannot remove the last function', 'warning');
                return;
            }
            
            const func = functions[index];
            const functionName = func.name;
            
            if (removeFunctionFromData(index)) {
                renderFunctions();
                renderDataInput();
                debouncedChartUpdate();
                showToast(`Removed ${functionName} function`, 'success');
                announceChange(`Removed ${functionName} function`);
            } else {
                showToast('Failed to remove function', 'error');
            }
        }
        
        /**
         * Move function up in the order
         * @param {number} index - Current index of function
         */
        function moveFunctionUp(index) {
            if (moveFunctionUp(index)) {
                renderFunctions();
                debouncedChartUpdate();
                showToast(`Moved ${functions[index - 1].name} up`, 'success');
                announceChange(`Moved ${functions[index - 1].name} up`);
            }
        }
        
        /**
         * Move function down in the order
         * @param {number} index - Current index of function
         */
        function moveFunctionDown(index) {
            if (moveFunctionDown(index)) {
                renderFunctions();
                debouncedChartUpdate();
                showToast(`Moved ${functions[index + 1].name} down`, 'success');
                announceChange(`Moved ${functions[index + 1].name} down`);
            }
        }
        
        /**
         * Start editing a function name
         * @param {number} index - Index of function to edit
         */
        function startEditFunction(index) {
            if (startEditFunction(index)) {
                renderFunctions();
                // Focus will be handled by autofocus in the input
            }
        }
        
        /**
         * Save function name edit
         * @param {number} index - Index of function being edited
         * @param {string} newName - New name for the function
         */
        function saveFunctionEdit(index, newName) {
            if (saveFunctionEdit(index, newName)) {
                renderFunctions();
                renderDataInput();
                debouncedChartUpdate();
                showToast('Function renamed successfully', 'success');
                announceChange(`Renamed function to ${newName}`);
            } else {
                showToast('Invalid name or name already exists', 'error');
                // Re-render to show original name
                renderFunctions();
            }
        }
        
        /**
         * Cancel function name edit
         * @param {number} index - Index of function to cancel edit
         */
        function cancelFunctionEdit(index) {
            if (cancelFunctionEdit(index)) {
                renderFunctions();
            }
        }
        
        // ===== CHART MAXIMIZATION HANDLERS =====
        
        /**
         * Toggle chart between normal and maximized view
         */
        function toggleChartMaximize() {
            const overlay = document.getElementById('chartMaximizeOverlay');
            const button = document.getElementById('maximizeChart');
            
            if (!overlay || !button) return;
            
            isChartMaximized = !isChartMaximized;
            
            if (isChartMaximized) {
                // Show maximized view
                overlay.style.display = 'block';
                button.textContent = 'Minimize Chart';
                button.setAttribute('aria-label', 'Minimize chart to normal view');
                
                // Create maximized chart
                setTimeout(() => {
                    if (typeof createMaximizedChart === 'function') {
                        createMaximizedChart();
                    }
                }, 100);
                
                // Trap focus within overlay
                trapFocus(overlay);
                
                showToast('Chart maximized to full screen', 'info');
                announceChange('Chart maximized to full screen');
            } else {
                // Hide maximized view
                overlay.style.display = 'none';
                button.textContent = 'Maximize Chart';
                button.setAttribute('aria-label', 'Expand chart to full viewport size');
                
                // Destroy maximized chart
                if (maximizedChart) {
                    maximizedChart.destroy();
                    maximizedChart = null;
                }
                
                showToast('Chart minimized to normal view', 'info');
                announceChange('Chart minimized to normal view');
            }
        }
        
        /**
         * Trap focus within a container element
         * @param {HTMLElement} container - Container to trap focus within
         */
        function trapFocus(container) {
            const focusableElements = container.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            
            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];
            
            if (firstElement) firstElement.focus();
            
            const handleKeydown = function(e) {
                if (e.key === 'Tab') {
                    if (e.shiftKey) {
                        if (document.activeElement === firstElement) {
                            e.preventDefault();
                            lastElement.focus();
                        }
                    } else {
                        if (document.activeElement === lastElement) {
                            e.preventDefault();
                            firstElement.focus();
                        }
                    }
                }
                
                if (e.key === 'Escape') {
                    toggleChartMaximize();
                }
            };
            
            container.addEventListener('keydown', handleKeydown);
            
            // Store the handler so it can be removed later
            container._focusTrapHandler = handleKeydown;
        }
        
        // ===== EXPORT FUNCTIONALITY =====
        
        /**
         * Export current chart as image and store in memory
         */
        function exportChartImage() {
            const canvas = document.getElementById('qaChart');
            if (!canvas || !chart) {
                showToast('No chart available to export', 'error');
                return;
            }
            
            try {
                // Show loading state
                const exportButton = document.getElementById('exportChart');
                toggleLoadingState(exportButton, true);
                
                // Create high-quality image data
                const imageData = canvas.toDataURL('image/png', 1.0);
                
                // Generate unique filename
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const filename = `chart_export_${exportCounter}_${timestamp}.png`;
                
                // Store in memory
                const exportedImage = {
                    id: exportCounter,
                    filename: filename,
                    dataUrl: imageData,
                    timestamp: new Date(),
                    chartType: document.getElementById('chartType')?.value || 'bar',
                    functionsCount: functions.length,
                    categoriesCount: categories.length
                };
                
                exportedImages.push(exportedImage);
                // Memory management: keep only last 10 exports
                if (exportedImages.length > 10) {
                    exportedImages.shift(); // Remove oldest export
                }
                exportCounter++;
                
                // Create a temporary download element to show the image was captured
                createImagePreview(exportedImage);
                
                toggleLoadingState(exportButton, false);
                showToast(`Chart exported as ${filename}`, 'success');
                announceChange(`Chart exported as ${filename} and stored in memory`);
                
            } catch (error) {
                console.error('Export failed:', error);
                const exportButton = document.getElementById('exportChart');
                toggleLoadingState(exportButton, false);
                showToast('Failed to export chart. Please try again.', 'error');
            }
        }
        
        /**
         * Create a preview of the exported image
         * @param {Object} exportedImage - Exported image data
         */
        function createImagePreview(exportedImage) {
            const preview = document.createElement('div');
            preview.className = 'image-preview fade-in';
            preview.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: white;
                border: 2px solid #667eea;
                border-radius: 8px;
                padding: 15px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                z-index: 1000;
                max-width: 300px;
            `;
            
            preview.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <strong>Image Exported</strong>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: #f44336; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;"
                            aria-label="Close preview"></button>
                </div>
                <img src="${exportedImage.dataUrl}" 
                     style="width: 100%; height: auto; border-radius: 4px; margin-bottom: 10px;"
                     alt="Exported chart preview">
                <div style="font-size: 12px; color: #666;">
                    <div>Filename: ${exportedImage.filename}</div>
                    <div>Stored in memory (ID: ${exportedImage.id})</div>
                </div>
            `;
            
            document.body.appendChild(preview);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (preview.parentElement) {
                    preview.remove();
                }
            }, 5000);
        }
        
        // ===== GLOBAL EVENT LISTENERS =====
        
        /**
         * Setup global event listeners (keyboard shortcuts, etc.)
         */
        function setupGlobalEventListeners() {
            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // Enter key for adding items
                if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey) {
                    if (e.target.id === 'newCategoryName') {
                        e.preventDefault();
                        addCategory();
                    } else if (e.target.id === 'newFunctionName') {
                        e.preventDefault();
                        addFunction();
                    } else if (e.target.id === 'newYearName') {
                        e.preventDefault();
                        addYear();
                    }
                }
                // Escape key to close maximized view or cancel edits
                else if (e.key === 'Escape') {
                    if (isChartMaximized) {
                        toggleChartMaximize();
                    } else {
                        // Cancel any active edits
                        cancelAllEditModes();
                        renderAllComponents();
                    }
                }
                // Ctrl+E for export
                else if (e.ctrlKey && e.key === 'e') {
                    e.preventDefault();
                    exportChartImage();
                }
                // Ctrl+M for maximize/minimize
                else if (e.ctrlKey && e.key === 'm') {
                    e.preventDefault();
                    toggleChartMaximize();
                }
                // Ctrl+S for save (prevent browser save dialog)
                else if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    // Could implement save functionality here
                    showToast('Use Export button to save chart image', 'info');
                }
            });
            
            // Focus management for accessibility
            document.addEventListener('focusin', function(e) {
                if (e.target.matches('.function-input, .chart-container, .trend-container')) {
                    e.target.style.borderColor = '#667eea';
                }
            });
            
            document.addEventListener('focusout', function(e) {
                if (e.target.matches('.function-input, .chart-container, .trend-container')) {
                    e.target.style.borderColor = 'transparent';
                }
            });
            
            // Handle clicks outside of edit elements to cancel editing
            document.addEventListener('click', function(e) {
                // Check if click is outside any edit input
                if (!e.target.closest('.item-name-input') && 
                    !e.target.closest('button') &&
                    !e.target.closest('.year-controls') &&
                    !e.target.closest('.item')) {
                    
                    // Cancel any active edits
                    const hasActiveEdits = functions.some(f => f.editable) || 
                                         categories.some(c => c.editable) || 
                                         years.some(y => y.editable);
                    
                    if (hasActiveEdits) {
                        cancelAllEditModes();
                        renderAllComponents();
                        announceChange('Cancelled editing');
                    }
                }
            });
        }
        
        // ===== WINDOW EVENT LISTENERS =====
        
        /**
         * Setup window and resize event listeners
         */
        function setupWindowEventListeners() {
            // Window resize handling for responsive behavior
            window.addEventListener('resize', debounce(function() {
                try {
                    if (chart) {
                        chart.resize();
                    }
                    if (maximizedChart) {
                        maximizedChart.resize();
                    }
                    
                    // Update responsive elements
                    updateResponsiveElements();
                    
                } catch (error) {
                    console.error('Error handling window resize:', error);
                }
            }, 250));
            
            // Window unload cleanup
            window.addEventListener('beforeunload', function(e) {
                // Check for unsaved edits
                const hasActiveEdits = functions.some(f => f.editable) || 
                                     categories.some(c => c.editable) || 
                                     years.some(y => y.editable);
                
                if (hasActiveEdits) {
                    const message = 'You have unsaved changes. Are you sure you want to leave?';
                    e.returnValue = message;
                    return message;
                }
                
                // Cleanup resources
                if (typeof cleanupUI === 'function') {
                    cleanupUI();
                }
            });
            
            // Handle visibility changes (tab switching)
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    // Page is now hidden - pause animations or intensive operations
                    if (updateTimeout) {
                        clearTimeout(updateTimeout);
                    }
                } else {
                    // Page is now visible - resume operations
                    if (chart && typeof chart.resize === 'function') {
                        chart.resize();
                    }
                }
            });
        }
        
        /**
         * Update responsive elements on window resize
         */
        function updateResponsiveElements() {
            const windowWidth = window.innerWidth;
            
            // Adjust layout based on screen size
            if (windowWidth < 768) {
                // Mobile layout adjustments
                adjustMobileLayout();
            } else if (windowWidth < 992) {
                // Tablet layout adjustments
                adjustTabletLayout();
            } else {
                // Desktop layout adjustments
                adjustDesktopLayout();
            }
        }
        
        /**
         * Adjust layout for mobile devices
         */
        function adjustMobileLayout() {
            const dashboard = document.getElementById('dashboardGrid');
            if (dashboard) {
                dashboard.style.gridTemplateColumns = '1fr';
            }
            
            // Stack controls vertically on mobile
            const controls = document.querySelector('.controls');
            if (controls) {
                controls.style.gridTemplateColumns = '1fr';
            }
        }
        
        /**
         * Adjust layout for tablet devices
         */
        function adjustTabletLayout() {
            const dashboard = document.getElementById('dashboardGrid');
            if (dashboard) {
                dashboard.style.gridTemplateColumns = '1fr';
            }
            
            // Use 2-column layout for controls on tablet
            const controls = document.querySelector('.controls');
            if (controls) {
                controls.style.gridTemplateColumns = 'repeat(auto-fit, minmax(120px, 1fr))';
            }
        }
        
        /**
         * Adjust layout for desktop devices
         */
        function adjustDesktopLayout() {
            const dashboard = document.getElementById('dashboardGrid');
            if (dashboard) {
                dashboard.style.gridTemplateColumns = '1fr 400px';
            }
            
            // Use multi-column layout for controls on desktop
            const controls = document.querySelector('.controls');
            if (controls) {
                controls.style.gridTemplateColumns = 'repeat(auto-fit, minmax(150px, 1fr))';
            }
        }
        
        // ===== DATA VALIDATION EVENT HANDLERS =====
        
        /**
         * Handle real-time data validation during input
         * @param {Event} e - Input event
         */
        function handleDataValidation(e) {
            if (e.target.type === 'number' && e.target.id.includes('-')) {
                validateNumericInput(e.target);
                
                // Update chart in real-time for immediate feedback
                if (e.target.value !== '') {
                    const parts = e.target.id.split('-');
                    if (parts.length >= 3) {
                        const functionId = parts[0];
                        const yearId = parts[1];
                        const categoryId = parts[2];
                        const categoryIndex = getCategoryIndexById(categoryId);
                        
                        if (categoryIndex !== -1) {
                            handleDataInput(functionId, yearId, categoryIndex, e.target.value);
                        }
                    }
                }
            }
        }
        
        // ===== ERROR HANDLING FOR EVENTS =====
        
        /**
         * Global error handler for event-related errors
         * @param {Error} error - Error object
         * @param {string} context - Context where error occurred
         */
        function handleEventError(error, context = 'event handling') {
            console.error(`Error in ${context}:`, error);
            showToast(`Error in ${context}`, 'error');
            
            // Clear any loading states
            document.querySelectorAll('.loading').forEach(el => {
                toggleLoadingState(el, false);
            });
            
            // Announce error to screen readers
            announceChange(`Error occurred in ${context}`);
        }
        
        // ===== FORM VALIDATION HELPERS =====
        
        /**
         * Validate form inputs before submission
         * @param {HTMLFormElement} form - Form element to validate
         * @returns {boolean} True if form is valid
         */
        function validateForm(form) {
            if (!form) return false;
            
            const inputs = form.querySelectorAll('input[required], select[required]');
            let isValid = true;
            
            inputs.forEach(input => {
                if (!input.value.trim()) {
                    input.style.borderColor = '#f44336';
                    isValid = false;
                } else {
                    input.style.borderColor = '';
                }
            });
            
            return isValid;
        }
        
        /**
         * Clear form validation errors
         * @param {HTMLFormElement} form - Form element to clear
         */
        function clearFormErrors(form) {
            if (!form) return;
            
            const inputs = form.querySelectorAll('input, select');
            inputs.forEach(input => {
                input.style.borderColor = '';
            });
        }
        
        // ===== ACCESSIBILITY EVENT HANDLERS =====
        
        /**
         * Handle accessibility-related events
         */
        function setupAccessibilityEventHandlers() {
            // Handle high contrast mode changes
            if (window.matchMedia) {
                const highContrastQuery = window.matchMedia('(prefers-high-contrast: active)');
                highContrastQuery.addListener(function(e) {
                    if (e.matches) {
                        document.body.classList.add('high-contrast');
                        announceChange('High contrast mode enabled');
                    } else {
                        document.body.classList.remove('high-contrast');
                        announceChange('High contrast mode disabled');
                    }
                });
                
                // Handle reduced motion preferences
                const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
                reducedMotionQuery.addListener(function(e) {
                    if (e.matches) {
                        document.body.classList.add('reduced-motion');
                        // Disable animations in chart
                        const animationSelect = document.getElementById('animation');
                        if (animationSelect) {
                            animationSelect.value = 'false';
                            debouncedChartUpdate();
                        }
                        announceChange('Reduced motion mode enabled');
                    } else {
                        document.body.classList.remove('reduced-motion');
                        announceChange('Reduced motion mode disabled');
                    }
                });
            }
            
            // Handle screen reader announcements for dynamic content
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === Node.ELEMENT_NODE && node.classList?.contains('fade-in')) {
                                // Announce new content to screen readers
                                const label = node.getAttribute('aria-label') || node.textContent?.substring(0, 50);
                                if (label) {
                                    announceChange(`New content added: ${label}`);
                                }
                            }
                        });
                    }
                });
            });
            
            // Observe changes in main content areas
            const mainContent = document.getElementById('main-content');
            const sidebar = document.querySelector('.sidebar');
            
            if (mainContent) observer.observe(mainContent, { childList: true, subtree: true });
            if (sidebar) observer.observe(sidebar, { childList: true, subtree: true });
        }
        
        // ===== DRAG AND DROP EVENT HANDLERS =====
        
        /**
         * Setup drag and drop functionality for reordering functions
         */
        function setupDragAndDropEventHandlers() {
            // Enable drag and drop for function reordering
            const functionsList = document.getElementById('functionsList');
            if (!functionsList) return;
            
            let draggedElement = null;
            let draggedIndex = -1;
            
            functionsList.addEventListener('dragstart', function(e) {
                if (e.target.classList.contains('sort-item')) {
                    draggedElement = e.target;
                    draggedIndex = Array.from(functionsList.children).indexOf(e.target);
                    e.target.style.opacity = '0.5';
                    
                    // Set drag data
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', e.target.outerHTML);
                }
            });
            
            functionsList.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const afterElement = getDragAfterElement(functionsList, e.clientY);
                if (afterElement == null) {
                    functionsList.appendChild(draggedElement);
                } else {
                    functionsList.insertBefore(draggedElement, afterElement);
                }
            });
            
            functionsList.addEventListener('dragend', function(e) {
                if (e.target === draggedElement) {
                    e.target.style.opacity = '';
                    
                    // Calculate new index
                    const newIndex = Array.from(functionsList.children).indexOf(e.target);
                    
                    if (newIndex !== draggedIndex && newIndex !== -1) {
                        // Reorder functions array
                        const movedFunction = functions.splice(draggedIndex, 1)[0];
                        functions.splice(newIndex, 0, movedFunction);
                        
                        // Update UI and charts
                        renderFunctions();
                        debouncedChartUpdate();
                        showToast(`Moved ${movedFunction.name} to position ${newIndex + 1}`, 'success');
                        announceChange(`Moved ${movedFunction.name} to new position`);
                    }
                    
                    draggedElement = null;
                    draggedIndex = -1;
                }
            });
        }
        
        /**
         * Get the element after which to insert during drag operation
         * @param {HTMLElement} container - Container element
         * @param {number} y - Y coordinate
         * @returns {HTMLElement|null} Element to insert after
         */
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.sort-item:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        
        // ===== TOUCH EVENT HANDLERS FOR MOBILE =====
        
        /**
         * Setup touch event handlers for mobile interactions
         */
        function setupTouchEventHandlers() {
            let touchStartX = 0;
            let touchStartY = 0;
            
            document.addEventListener('touchstart', function(e) {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            }, { passive: true });
            
            document.addEventListener('touchend', function(e) {
                if (e.changedTouches.length === 1) {
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchEndY - touchStartY;
                    
                    // Detect swipe gestures
                    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                        if (deltaX > 0) {
                            // Swipe right - could implement function navigation
                            console.log('Swipe right detected');
                        } else {
                            // Swipe left - could implement function navigation
                            console.log('Swipe left detected');
                        }
                    }
                }
            }, { passive: true });
        }
        
        // ===== INITIALIZATION AND CLEANUP =====
        
        /**
         * Initialize all event handlers
         */
        function initializeAllEventHandlers() {
            try {
                console.log('Initializing all event handlers...');
                
                // Core event listeners
                initializeEventListeners();
                
                // Accessibility event handlers
                setupAccessibilityEventHandlers();
                
                // Drag and drop for desktop
                if (window.innerWidth >= 768) {
                    setupDragAndDropEventHandlers();
                }
                
                // Touch events for mobile
                if ('ontouchstart' in window) {
                    setupTouchEventHandlers();
                }
                
                // Real-time data validation
                document.addEventListener('input', handleDataValidation);
                
                console.log('All event handlers initialized successfully');
                
            } catch (error) {
                handleEventError(error, 'event handler initialization');
            }
        }
        
        /**
         * Cleanup all event handlers
         */
        function cleanupEventHandlers() {
            try {
                // Remove global event listeners
                document.removeEventListener('input', handleDataValidation);
                
                // Clear any timeouts
                if (updateTimeout) {
                    clearTimeout(updateTimeout);
                    updateTimeout = null;
                }
                
                // Remove focus trap handlers
                document.querySelectorAll('[data-focus-trap]').forEach(el => {
                    if (el._focusTrapHandler) {
                        el.removeEventListener('keydown', el._focusTrapHandler);
                        delete el._focusTrapHandler;
                    }
                });
                
                console.log('Event handlers cleanup completed');
                
            } catch (error) {
                console.error('Error during event handlers cleanup:', error);
            }
        }
        
        /* ===========================================
           END OF PART 4: EVENT HANDLERS & USER INTERACTIONS
           =========================================== */
        /* ===========================================
           PART 5: CHART CREATION & ADVANCED FEATURES
           =========================================== */
        
        // ===== MAIN CHART CREATION FUNCTIONS =====
        
        /**
         * Create the main stacked bar/column chart with trend lines
         * Handles all chart configuration, data preparation, and rendering
         */
        function createMainChart() {
            const ctx = document.getElementById('qaChart').getContext('2d');
            const sortedFunctions = getSortedFunctions();
            const prevYear = getPreviousYear();
            const currYear = getCurrentYear();
            
            if (!prevYear || !currYear) {
                console.warn('Cannot create chart: Missing year configuration');
                return;
            }
            
            // Generate dynamic labels with spacing controls
            const labels = generateChartLabels(sortedFunctions);
            
            // Get display options from UI controls
            const showDataLabels = document.getElementById('showDataLabels')?.checked || false;
            const showValues = document.getElementById('showValues')?.checked || false;
            const showPercentages = document.getElementById('showPercentages')?.checked || false;
            const showTrendLine = document.getElementById('showTrendLine')?.checked || false;
            const chartType = document.getElementById('chartType')?.value || 'bar';
            const animation = document.getElementById('animation')?.value === 'true';
            
            // Generate datasets for bars and trend lines
            const datasets = generateChartDatasets(
                sortedFunctions, 
                labels, 
                showDataLabels, 
                showValues, 
                showPercentages, 
                showTrendLine
            );
            
            // Create chart configuration
            const config = {
                type: chartType,
                data: { labels, datasets },
                options: createMainChartOptions(chartType, animation, showTrendLine, prevYear, currYear),
                plugins: [createFunctionNamePlugin(sortedFunctions, labels)]
            };
            
            // Destroy existing chart and create new one
            if (chart) {
                chart.destroy();
            }
            chart = new Chart(ctx, config);
            
            // Update supporting elements
            updateLegend();
            updateChartAccessibility();
        }
        
        /**
         * Generate chart labels with proper spacing
         * @param {Array} sortedFunctions - Array of sorted function objects
         * @returns {Array} Array of labels with spacing
         */
        function generateChartLabels(sortedFunctions) {
            const labels = [];
            const prevYear = getPreviousYear();
            const currYear = getCurrentYear();
            
            sortedFunctions.forEach((func, funcIndex) => {
                // Add previous year label
                labels.push(prevYear.name);
                
                // Add column spacing between years within same function
                for (let i = 0; i < columnSpacing; i++) {
                    labels.push('');
                }
                
                // Add current year label
                labels.push(currYear.name);
                
                // Add category gap between different functions (except last one)
                if (funcIndex < sortedFunctions.length - 1) {
                    for (let i = 0; i < categoryGap; i++) {
                        labels.push('');
                    }
                }
            });
            
            return labels;
        }
        
        /**
         * Generate all datasets for the main chart (bars + trend lines)
         * @param {Array} sortedFunctions - Sorted functions array
         * @param {Array} labels - Chart labels array
         * @param {boolean} showDataLabels - Whether to show data labels
         * @param {boolean} showValues - Whether to show values
         * @param {boolean} showPercentages - Whether to show percentages
         * @param {boolean} showTrendLine - Whether to show trend lines
         * @returns {Array} Array of Chart.js datasets
         */
        function generateChartDatasets(sortedFunctions, labels, showDataLabels, showValues, showPercentages, showTrendLine) {
            const datasets = [];
            const prevYear = getPreviousYear();
            const currYear = getCurrentYear();
            
            // Generate bar datasets for each category
            categories.forEach((category, catIndex) => {
                const { dataPrev, dataCurr, trendDataPrev, trendDataCurr } = 
                    generateCategoryData(sortedFunctions, category, catIndex, labels.length);
                
                // Previous year bars
                datasets.push(createBarDataset(
                    category, 
                    prevYear, 
                    dataPrev, 
                    'previous', 
                    showDataLabels && showValues
                ));
                
                // Current year bars
                datasets.push(createBarDataset(
                    category, 
                    currYear, 
                    dataCurr, 
                    'current', 
                    showDataLabels && showValues
                ));
                
                // Trend lines (if enabled) - FIXED TO SHOW CONNECTED LINES
                if (showTrendLine && trendLineConfig[category.id]?.enabled) {
                    datasets.push(createTrendDataset(
                        category, 
                        trendDataPrev,
                        trendDataCurr,
                        sortedFunctions,
                        showDataLabels && showPercentages
                    ));
                }
            });
            
            return datasets;
        }
        
        /**
         * Generate data arrays for a specific category
         * @param {Array} sortedFunctions - Sorted functions
         * @param {Object} category - Category object
         * @param {number} catIndex - Category index
         * @param {number} totalLength - Total length of data array needed
         * @returns {Object} Object with data arrays for previous/current years
         */
        function generateCategoryData(sortedFunctions, category, catIndex, totalLength) {
            const dataPrev = new Array(totalLength).fill(null);
            const dataCurr = new Array(totalLength).fill(null);
            const trendDataPrev = new Array(totalLength).fill(null);
            const trendDataCurr = new Array(totalLength).fill(null);
            
            const prevYear = getPreviousYear();
            const currYear = getCurrentYear();
            
            let dataIndex = 0;
            
            sortedFunctions.forEach((func, funcIndex) => {
                // Get raw values
                const valuePrev = getDataValue(func.id, prevYear.id, catIndex);
                const valueCurr = getDataValue(func.id, currYear.id, catIndex);
                
                // Calculate percentages with 2 decimal precision
                const percPrev = getCategoryPercentage(func.id, prevYear.id, catIndex);
                const percCurr = getCategoryPercentage(func.id, currYear.id, catIndex);
                
                // Previous year data
                dataPrev[dataIndex] = valuePrev;
                trendDataPrev[dataIndex] = percPrev;
                
                // Skip column spacing
                dataIndex += columnSpacing + 1;
                
                // Current year data
                dataCurr[dataIndex] = valueCurr;
                trendDataCurr[dataIndex] = percCurr;
                
                // Move to next function group
                dataIndex += 1;
                
                // Add category gap (except for last function)
                if (funcIndex < sortedFunctions.length - 1) {
                    dataIndex += categoryGap;
                }
            });
            
            return { dataPrev, dataCurr, trendDataPrev, trendDataCurr };
        }
        
        /**
         * Create a bar dataset configuration
         * @param {Object} category - Category object
         * @param {Object} year - Year object
         * @param {Array} data - Data array
         * @param {string} yearType - 'previous' or 'current'
         * @param {boolean} showLabels - Whether to show data labels
         * @returns {Object} Chart.js dataset configuration
         */
        function createBarDataset(category, year, data, yearType, showLabels) {
            const opacity = getOpacity(yearType);
            
            return {
                label: `${category.name} ${year.name}`,
                data: data,
                backgroundColor: category.color + opacity,
                borderColor: category.color,
                borderWidth: 1,
                borderRadius: 4,
                borderSkipped: false,
                stack: 'combined',
                datalabels: {
                    display: showLabels,
                    anchor: 'center',
                    align: 'center',
                    color: textStyles.dataLabels.color,
                    font: {
                        weight: textStyles.dataLabels.fontWeight,
                        size: textStyles.dataLabels.fontSize
                    },
                    formatter: (value) => value > 0 ? value : '',
                    clip: false
                }
            };
        }
        
        /**
         * Create a trend line dataset configuration - FIXED VERSION
         * @param {Object} category - Category object
         * @param {Array} trendDataPrev - Previous year trend data
         * @param {Array} trendDataCurr - Current year trend data
         * @param {Array} sortedFunctions - Sorted functions for proper line connection
         * @param {boolean} showLabels - Whether to show percentage labels
         * @returns {Object} Chart.js dataset configuration
         */
        function createTrendDataset(category, trendDataPrev, trendDataCurr, sortedFunctions, showLabels) {
            const config = trendLineConfig[category.id] || {};
            const trendColor = config.color || category.color;
            const thickness = config.thickness || 2;
            const pointSize = config.pointSize || 4;
            const opacity = config.opacity || 1.0;
            const showPoints = config.showPoints !== false;
            const showLine = config.showLine !== false;
            
            // Create connected line data - only include actual data points, skip nulls
            const connectedData = [];
            let dataIndex = 0;
            
            sortedFunctions.forEach((func, funcIndex) => {
                // Previous year point
                connectedData.push({
                    x: dataIndex,
                    y: trendDataPrev[dataIndex]
                });
                
                // Move to current year position
                dataIndex += columnSpacing + 1;
                
                // Current year point
                connectedData.push({
                    x: dataIndex,
                    y: trendDataCurr[dataIndex]
                });
                
                // Move to next function group
                dataIndex += 1;
                
                // Add category gap (except for last function)
                if (funcIndex < sortedFunctions.length - 1) {
                    dataIndex += categoryGap;
                }
            });
            
            return {
                label: `${category.name} Trend`,
                data: connectedData,
                type: 'line',
                borderColor: trendColor,
                backgroundColor: 'transparent',
                borderWidth: thickness,
                pointRadius: showPoints ? pointSize : 0,
                pointBackgroundColor: trendColor,
                pointBorderColor: '#fff',
                pointBorderWidth: 2,
                showLine: showLine,
                tension: 0.2, // Smooth curve
                yAxisID: 'y1',
                opacity: opacity,
                spanGaps: false, // Don't connect gaps in data
                datalabels: {
                    display: showLabels,
                    backgroundColor: 'rgba(255,255,255,0.9)',
                    borderColor: trendColor,
                    borderRadius: 4,
                    borderWidth: 1,
                    color: textStyles.dataLabels.color,
                    font: {
                        weight: textStyles.dataLabels.fontWeight,
                        size: Math.max(8, textStyles.dataLabels.fontSize - 2)
                    },
                    padding: 4,
                    formatter: (value, context) => {
                        // Only show labels for actual data points
                        if (value && typeof value === 'object' && value.y !== null) {
                            return value.y.toFixed(1) + '%';
                        }
                        return '';
                    },
                    clip: false
                }
            };
        }
        
        /**
         * Create chart options configuration for main chart
         * @param {string} chartType - Chart type ('bar' or 'horizontalBar')
         * @param {boolean} animation - Whether to enable animations
         * @param {boolean} showTrendLine - Whether trend lines are shown
         * @param {Object} prevYear - Previous year object
         * @param {Object} currYear - Current year object
         * @returns {Object} Chart.js options configuration
         */
        function createMainChartOptions(chartType, animation, showTrendLine, prevYear, currYear) {
            return {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: animation ? 750 : 0,
                    easing: 'easeInOutQuart'
                },
                layout: {
                    padding: {
                        top: 50, // Space for function names
                        bottom: 20,
                        left: 10,
                        right: showTrendLine ? 60 : 10 // Space for secondary axis
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: `Quality Assurance Review Results (${prevYear.name} vs ${currYear.name})`,
                        color: textStyles.title.color,
                        font: {
                            size: textStyles.title.fontSize,
                            weight: textStyles.title.fontWeight
                        },
                        padding: 20
                    },
                    legend: {
                        display: false // We use custom legend
                    },
                    tooltip: createTooltipConfiguration(),
                    datalabels: {
                        display: false // Controlled individually per dataset
                    }
                },
                scales: createScalesConfiguration(chartType, showTrendLine),
                interaction: {
                    mode: 'index',
                    intersect: false
                }
            };
        }
        
        /**
         * Create tooltip configuration
         * @returns {Object} Tooltip configuration
         */
        function createTooltipConfiguration() {
            return {
                enabled: true,
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0,0,0,0.9)',
                titleColor: '#fff',
                bodyColor: '#fff',
                borderColor: '#667eea',
                borderWidth: 2,
                cornerRadius: 8,
                displayColors: true,
                titleFont: {
                    size: 14,
                    weight: 'bold'
                },
                bodyFont: {
                    size: 12
                },
                padding: 12,
                callbacks: {
                    title: function(context) {
                        if (!context.length) return '';
                        
                        const dataIndex = context[0].dataIndex;
                        const sortedFunctions = getSortedFunctions();
                        
                        // Determine which function and year this data point belongs to
                        let currentIndex = 0;
                        for (let i = 0; i < sortedFunctions.length; i++) {
                            if (dataIndex === currentIndex) {
                                return `${sortedFunctions[i].name} ${getPreviousYear().name}`;
                            } else if (dataIndex === currentIndex + columnSpacing + 1) {
                                return `${sortedFunctions[i].name} ${getCurrentYear().name}`;
                            }
                            currentIndex += 2 + columnSpacing + (i < sortedFunctions.length - 1 ? categoryGap : 0);
                        }
                        
                        return 'Data Point';
                    },
                    label: function(context) {
                        if (context.parsed.y === null) return '';
                        
                        const label = context.dataset.label;
                        const value = context.parsed.y;
                        
                        // Format based on dataset type
                        if (label.includes('Trend')) {
                            return `${label}: ${value.toFixed(2)}%`;
                        } else {
                            return `${label}: ${value}`;
                        }
                    },
                    afterBody: function(context) {
                        if (!context.length) return '';
                        
                        const dataIndex = context[0].dataIndex;
                        const sortedFunctions = getSortedFunctions();
                        
                        // Find the function for this data point
                        let func = null;
                        let yearId = null;
                        let currentIndex = 0;
                        
                        for (let i = 0; i < sortedFunctions.length; i++) {
                            if (dataIndex === currentIndex) {
                                func = sortedFunctions[i];
                                yearId = getPreviousYear().id;
                                break;
                            } else if (dataIndex === currentIndex + columnSpacing + 1) {
                                func = sortedFunctions[i];
                                yearId = getCurrentYear().id;
                                break;
                            }
                            currentIndex += 2 + columnSpacing + (i < sortedFunctions.length - 1 ? categoryGap : 0);
                        }
                        
                        if (func && yearId) {
                            const total = getFunctionYearTotal(func.id, yearId);
                            return [`Total Reviews: ${total}`];
                        }
                        
                        return '';
                    }
                }
            };
        }
        
        /**
         * Create scales configuration for chart
         * @param {string} chartType - Chart type
         * @param {boolean} showTrendLine - Whether trend lines are shown
         * @returns {Object} Scales configuration
         */
        function createScalesConfiguration(chartType, showTrendLine) {
            const isHorizontal = chartType === 'horizontalBar';
            
            const scales = {
                x: {
                    stacked: true,
                    grid: {
                        display: false
                    },
                    ticks: {
                        callback: function(value, index) {
                            const label = this.getLabelForValue(value);
                            return label === '' ? '' : label;
                        },
                        maxRotation: isHorizontal ? 0 : 45,
                        minRotation: 0,
                        color: textStyles.axisLabels.color,
                        font: {
                            size: textStyles.axisLabels.fontSize,
                            weight: textStyles.axisLabels.fontWeight
                        }
                    }
                },
                y: {
                    stacked: true,
                    ...getAxisConfig('primary'),
                    grid: {
                        color: 'rgba(0,0,0,0.1)',
                        lineWidth: 1
                    },
                    ticks: {
                        color: textStyles.axisLabels.color,
                        font: {
                            size: textStyles.axisLabels.fontSize,
                            weight: textStyles.axisLabels.fontWeight
                        }
                    },
                    title: {
                        display: true,
                        text: 'Number of Accounts',
                        color: textStyles.title.color,
                        font: {
                            size: textStyles.title.fontSize,
                            weight: textStyles.title.fontWeight
                        }
                    }
                }
            };
            
            // Add secondary axis for trend lines
            if (showTrendLine) {
                scales.y1 = {
                    type: 'linear',
                    display: true,
                    position: isHorizontal ? 'top' : 'right',
                    ...getAxisConfig('secondary'),
                    grid: {
                        drawOnChartArea: false
                    },
                    ticks: {
                        color: textStyles.axisLabels.color,
                        font: {
                            size: textStyles.axisLabels.fontSize,
                            weight: textStyles.axisLabels.fontWeight
                        },
                        callback: function(value) {
                            return value + '%';
                        }
                    },
                    title: {
                        display: true,
                        text: 'Percentage (%)',
                        color: textStyles.title.color,
                        font: {
                            size: textStyles.title.fontSize,
                            weight: textStyles.title.fontWeight
                        }
                    }
                };
            }
            
            return scales;
        }
        
        /**
         * Create plugin for rendering function names below the chart
         * @param {Array} sortedFunctions - Sorted functions array
         * @param {Array} labels - Chart labels array
         * @returns {Object} Chart.js plugin
         */
        function createFunctionNamePlugin(sortedFunctions, labels) {
            return {
                id: 'functionNames',
                afterDraw: function(chart) {
                    const ctx = chart.ctx;
                    const xAxis = chart.scales.x;
                    const yAxis = chart.scales.y;
                    
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillStyle = textStyles.functionNames.color;
                    ctx.font = `${textStyles.functionNames.fontWeight} ${textStyles.functionNames.fontSize}px Arial`;
                    
                    let labelIndex = 0;
                    sortedFunctions.forEach((func, funcIndex) => {
                        // Calculate center position between the two year columns for this function
                        const startPixel = xAxis.getPixelForValue(labelIndex);
                        const endPixel = xAxis.getPixelForValue(labelIndex + columnSpacing + 1);
                        const centerX = (startPixel + endPixel) / 2;
                        
                        // Position function name below the chart area
                        const yPosition = chart.chartArea.bottom + 25;
                        
                        ctx.fillText(func.name, centerX, yPosition);
                        
                        // Move to next function
                        labelIndex += 2 + columnSpacing + (funcIndex < sortedFunctions.length - 1 ? categoryGap : 0);
                    });
                    
                    ctx.restore();
                }
            };
        }
        
        // ===== MAXIMIZED CHART CREATION =====
        
        /**
         * Create maximized version of the main chart
         */
        function createMaximizedChart() {
            try {
                const canvas = document.getElementById('qaChartMaximized');
                if (!canvas) {
                    console.warn('Maximized chart canvas not found');
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    console.error('Cannot get 2D context for maximized chart');
                    return;
                }
                const sortedFunctions = getSortedFunctions();
                const prevYear = getPreviousYear();
                const currYear = getCurrentYear();
                
                if (!prevYear || !currYear) return;
                
                // Use same data generation as main chart
                const labels = generateChartLabels(sortedFunctions);
                const showDataLabels = document.getElementById('showDataLabels')?.checked || false;
                const showValues = document.getElementById('showValues')?.checked || false;
                const showPercentages = document.getElementById('showPercentages')?.checked || false;
                const showTrendLine = document.getElementById('showTrendLine')?.checked || false;
                const chartType = document.getElementById('chartType')?.value || 'bar';
                
                const datasets = generateChartDatasets(
                    sortedFunctions, 
                    labels, 
                    showDataLabels, 
                    showValues, 
                    showPercentages, 
                    showTrendLine
                );
                
                // Create maximized chart configuration with enhanced styling
                const config = {
                    type: chartType,
                    data: { labels, datasets },
                    options: {
                        ...createMainChartOptions(chartType, true, showTrendLine, prevYear, currYear),
                        layout: {
                            padding: {
                                top: 60,
                                bottom: 40,
                                left: 20,
                                right: showTrendLine ? 80 : 20
                            }
                        },
                        plugins: {
                            ...createMainChartOptions(chartType, true, showTrendLine, prevYear, currYear).plugins,
                            title: {
                                display: true,
                                text: `Quality Assurance Review Results (${prevYear.name} vs ${currYear.name}) - Maximized View`,
                                color: textStyles.title.color,
                                font: {
                                    size: Math.max(20, textStyles.title.fontSize + 4),
                                    weight: textStyles.title.fontWeight
                                },
                                padding: 30
                            }
                        }
                    },
                    plugins: [createFunctionNamePlugin(sortedFunctions, labels)]
                };
                
                // Create maximized chart
                if (maximizedChart) {
                    maximizedChart.destroy();
                }
                maximizedChart = new Chart(ctx, config);
            } catch (error) {
                console.error('Error creating maximized chart:', error);
                announceChange('Error creating maximized chart view');
                // Fallback: close the maximized view
                toggleChartMaximize();
            }
        }
        
        // ===== CHART ACCESSIBILITY =====
        
        /**
         * Update chart accessibility attributes and descriptions
         */
        function updateChartAccessibility() {
            const canvas = document.getElementById('qaChart');
            const prevYear = getPreviousYear();
            const currYear = getCurrentYear();
            
            if (!canvas || !prevYear || !currYear) return;
            
            let description = `Interactive chart showing quality assurance review results comparing ${prevYear.name} and ${currYear.name}. `;
            
            // Add summary statistics
            functions.forEach(func => {
                const prevTotal = getFunctionYearTotal(func.id, prevYear.id);
                const currTotal = getFunctionYearTotal(func.id, currYear.id);
                const prevPassRate = getCategoryPercentage(func.id, prevYear.id, 0);
                const currPassRate = getCategoryPercentage(func.id, currYear.id, 0);
                
                description += `${func.name}: ${prevYear.name} had ${prevTotal} reviews with ${prevPassRate.toFixed(1)}% pass rate, ${currYear.name} had ${currTotal} reviews with ${currPassRate.toFixed(1)}% pass rate. `;
            });
            
            // Add interaction instructions
            description += 'Use arrow keys to navigate chart elements. Press Tab to access chart controls.';
            
            canvas.setAttribute('aria-label', description);
            canvas.setAttribute('role', 'img');
            canvas.setAttribute('tabindex', '0');
        }
        
        // ===== CHART INTEGRATION FUNCTIONS =====
        
        /**
         * Create main chart (removed trend chart creation)
         * Main entry point for chart creation
         */
        function createCharts() {
            try {
                createMainChart();
                
                // Update related UI elements
                updateShadingPreview();
                updateTextStyleDisplays();
                
                console.log('Chart created successfully');
            } catch (error) {
                console.error('Error creating chart:', error);
                announceChange('Error creating chart. Please check your data.');
            }
        }
        
        // ===== EXPORT FUNCTIONALITY =====
        
        /**
         * Export current chart as image and store in memory
         */
        function exportChartImage() {
            const canvas = document.getElementById('qaChart');
            if (!canvas || !chart) {
                showToast('No chart available to export', 'error');
                return;
            }
            
            try {
                // Show loading state
                const exportButton = document.getElementById('exportChart');
                toggleLoadingState(exportButton, true);
                
                // Create high-quality image data
                const imageData = canvas.toDataURL('image/png', 1.0);
                
                // Generate unique filename
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const filename = `chart_export_${exportCounter}_${timestamp}.png`;
                
                // Store in memory
                const exportedImage = {
                    id: exportCounter,
                    filename: filename,
                    dataUrl: imageData,
                    timestamp: new Date(),
                    chartType: document.getElementById('chartType')?.value || 'bar',
                    functionsCount: functions.length,
                    categoriesCount: categories.length
                };
                
                exportedImages.push(exportedImage);
                // Memory management: keep only last 10 exports
                if (exportedImages.length > 10) {
                    exportedImages.shift(); // Remove oldest export
                }
                exportCounter++;
                
                // Create a temporary download element to show the image was captured
                createImagePreview(exportedImage);
                
                toggleLoadingState(exportButton, false);
                showToast(`Chart exported as ${filename}`, 'success');
                announceChange(`Chart exported as ${filename} and stored in memory`);
                
            } catch (error) {
                console.error('Export failed:', error);
                const exportButton = document.getElementById('exportChart');
                toggleLoadingState(exportButton, false);
                showToast('Failed to export chart. Please try again.', 'error');
            }
        }
        
        /**
         * Create a preview of the exported image
         * @param {Object} exportedImage - Exported image data
         */
        function createImagePreview(exportedImage) {
            const preview = document.createElement('div');
            preview.className = 'image-preview fade-in';
            preview.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: white;
                border: 2px solid #667eea;
                border-radius: 8px;
                padding: 15px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                z-index: 1000;
                max-width: 300px;
            `;
            
            preview.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <strong>Image Exported</strong>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: #f44336; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;"
                            aria-label="Close preview"></button>
                </div>
                <img src="${exportedImage.dataUrl}" 
                     style="width: 100%; height: auto; border-radius: 4px; margin-bottom: 10px;"
                     alt="Exported chart preview">
                <div style="font-size: 12px; color: #666;">
                    <div>Filename: ${exportedImage.filename}</div>
                    <div>Stored in memory (ID: ${exportedImage.id})</div>
                </div>
            `;
            
            document.body.appendChild(preview);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (preview.parentElement) {
                    preview.remove();
                }
            }, 5000);
        }
        
        // ===== ERROR HANDLING & VALIDATION =====
        
        /**
         * Validate chart data before rendering
         * @returns {Object} Validation result with status and issues
         */
        function validateChartData() {
            const issues = [];
            
            // Check for minimum requirements
            if (functions.length === 0) {
                issues.push('No functions configured');
            }
            if (categories.length === 0) {
                issues.push('No categories configured');
            }
            if (years.length < 2) {
                issues.push('At least two years required for comparison');
            }
            
            // Check for previous and current year designation
            const hasPrevious = years.some(y => y.type === 'previous');
            const hasCurrent = years.some(y => y.type === 'current');
            
            if (!hasPrevious) {
                issues.push('No year designated as "previous"');
            }
            if (!hasCurrent) {
                issues.push('No year designated as "current"');
            }
            
            // Check data completeness
            functions.forEach(func => {
                years.forEach(year => {
                    if (!functionData[func.id] || !functionData[func.id][year.id]) {
                        issues.push(`Missing data for ${func.name} in ${year.name}`);
                    } else if (functionData[func.id][year.id].length !== categories.length) {
                        issues.push(`Incomplete data for ${func.name} in ${year.name}`);
                    }
                });
            });
            
            return {
                valid: issues.length === 0,
                issues: issues
            };
        }
        
        /**
         * Handle chart creation errors gracefully
         * @param {Error} error - Error object
         * @param {string} context - Context where error occurred
         */
        function handleChartError(error, context = 'chart creation') {
            console.error(`Error in ${context}:`, error);
            
            // Show user-friendly error message
            const errorContainer = document.createElement('div');
            errorContainer.className = 'chart-error';
            errorContainer.style.cssText = `
                background: #ffebee;
                border: 2px solid #f44336;
                border-radius: 8px;
                padding: 20px;
                margin: 20px;
                color: #c62828;
                text-align: center;
            `;
            errorContainer.innerHTML = `
                <h3>Chart Error</h3>
                <p>There was an error creating the chart. Please check your data configuration.</p>
                <button onclick="this.parentElement.remove(); createCharts();" 
                        style="background: #f44336; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-top: 10px;">
                    Retry
                </button>
            `;
            
            // Replace chart container content with error message
            const chartContainer = document.getElementById('chartContainer');
            if (chartContainer) {
                chartContainer.appendChild(errorContainer);
            }
            
            announceChange(`Error in ${context}. Please check your configuration.`);
        }
        
        // ===== PERFORMANCE OPTIMIZATION FUNCTIONS =====
        
        /**
         * Optimize chart performance for large datasets
         */
        function optimizeChartPerformance() {
            // Disable animations for large datasets
            if (functions.length > 10 || categories.length > 8) {
                const animationSelect = document.getElementById('animation');
                if (animationSelect && animationSelect.value === 'true') {
                    animationSelect.value = 'false';
                    announceChange('Animations disabled for better performance with large dataset');
                }
            }
            
            // Reduce point sizes for trend lines if there are many data points
            const totalDataPoints = functions.length * years.length * categories.length;
            if (totalDataPoints > 100) {
                Object.keys(trendLineConfig).forEach(categoryId => {
                    if (trendLineConfig[categoryId].pointSize > 3) {
                        trendLineConfig[categoryId].pointSize = 3;
                    }
                });
            }
        }
        
        /**
         * Clean up chart instances and event listeners
         */
        function cleanup() {
            // Destroy chart instances
            if (chart) {
                chart.destroy();
                chart = null;
            }
            if (maximizedChart) {
                maximizedChart.destroy();
                maximizedChart = null;
            }
            
            // Clear exported images from memory
            exportedImages = [];
            exportCounter = 1;
            
            console.log('Chart cleanup completed');
        }
        
        // ===== BROWSER COMPATIBILITY FUNCTIONS =====
        
        /**
         * Check browser compatibility and provide fallbacks
         * @returns {Object} Compatibility status and missing features
         */
        function checkBrowserCompatibility() {
            const features = {
                canvas: !!document.createElement('canvas').getContext,
                es6: typeof(Array.from) === 'function',
                requestAnimationFrame: typeof(requestAnimationFrame) === 'function',
                chartjs: typeof(Chart) !== 'undefined'
            };
            
            const missing = Object.keys(features).filter(key => !features[key]);
            
            if (missing.length > 0) {
                console.warn('Missing browser features:', missing);
                
                // Show compatibility warning
                const warning = document.createElement('div');
                warning.style.cssText = `
                    background: #fff3cd;
                    border: 2px solid #ffc107;
                    border-radius: 8px;
                    padding: 15px;
                    margin: 10px;
                    color: #856404;
                `;
                warning.innerHTML = `
                    <strong>Browser Compatibility Notice:</strong>
                    Some chart features may not work properly in your browser. 
                    Please consider upgrading to a modern browser for the best experience.
                `;
                
                document.body.insertBefore(warning, document.body.firstChild);
            }
            
            return {
                compatible: missing.length === 0,
                missing: missing,
                features: features
            };
        }
        
        // ===== INITIALIZATION FUNCTION =====
        
        /**
         * Initialize the chart system
         * Sets up all components and renders initial state
         */
        function initializeChartSystem() {
            try {
                // Check browser compatibility
                const compatibility = checkBrowserCompatibility();
                
                if (!compatibility.features.chartjs) {
                    throw new Error('Chart.js library not loaded');
                }
                
                // Validate initial data
                const validation = validateChartData();
                if (!validation.valid) {
                    console.warn('Data validation issues:', validation.issues);
                    // Continue anyway with available data
                }
                
                // Optimize performance based on data size
                optimizeChartPerformance();
                
                // Create initial chart
                createCharts();
                
                // Set up chart accessibility
                updateChartAccessibility();
                
                console.log('Chart system initialized successfully');
                
            } catch (error) {
                console.error('Error initializing chart system:', error);
                handleChartError(error, 'chart system initialization');
            }
        }
        
        // ===== TREND LINE HELPER FUNCTIONS =====
        
        /**
         * Update trend line thickness display and configuration
         * @param {string} categoryId - Category identifier
         * @param {string} value - Thickness value
         */
        function updateTrendLineThickness(categoryId, value) {
            updateTrendLineDisplayValue(categoryId, 'thickness', value);
        }
        
        /**
         * Update trend line point size display and configuration
         * @param {string} categoryId - Category identifier
         * @param {string} value - Point size value
         */
        function updateTrendLinePointSize(categoryId, value) {
            updateTrendLineDisplayValue(categoryId, 'pointSize', value);
        }
        
        /**
         * Update trend line opacity display and configuration
         * @param {string} categoryId - Category identifier
         * @param {string} value - Opacity value (0-100)
         */
        function updateTrendLineOpacity(categoryId, value) {
            updateTrendLineDisplayValue(categoryId, 'opacity', value);
        }
        
        // ===== DATA EXPORT FOR CHARTS =====
        
        /**
         * Export chart data as CSV format
         * @returns {string} CSV formatted data
         */
        function exportChartDataAsCSV() {
            const prevYear = getPreviousYear();
            const currYear = getCurrentYear();
            
            if (!prevYear || !currYear) {
                return 'Error: Missing year configuration';
            }
            
            let csv = 'Function';
            
            // Add category headers for both years
            categories.forEach(category => {
                csv += `,${category.name} ${prevYear.name},${category.name} ${currYear.name}`;
            });
            csv += '\n';
            
            // Add data rows
            functions.forEach(func => {
                csv += func.name;
                
                categories.forEach((category, catIndex) => {
                    const prevValue = getDataValue(func.id, prevYear.id, catIndex);
                    const currValue = getDataValue(func.id, currYear.id, catIndex);
                    csv += `,${prevValue},${currValue}`;
                });
                csv += '\n';
            });
            
            return csv;
        }
        
        /**
         * Export chart data as JSON format
         * @returns {string} JSON formatted data
         */
        function exportChartDataAsJSON() {
            const prevYear = getPreviousYear();
            const currYear = getCurrentYear();
            
            if (!prevYear || !currYear) {
                return JSON.stringify({ error: 'Missing year configuration' });
            }
            
            const data = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    previousYear: prevYear.name,
                    currentYear: currYear.name,
                    totalFunctions: functions.length,
                    totalCategories: categories.length
                },
                categories: categories.map(c => ({ name: c.name, color: c.color })),
                data: functions.map(func => {
                    const functionData = {
                        name: func.name,
                        [prevYear.name]: {},
                        [currYear.name]: {}
                    };
                    
                    categories.forEach((category, catIndex) => {
                        functionData[prevYear.name][category.name] = getDataValue(func.id, prevYear.id, catIndex);
                        functionData[currYear.name][category.name] = getDataValue(func.id, currYear.id, catIndex);
                    });
                    
                    return functionData;
                })
            };
            
            return JSON.stringify(data, null, 2);
        }
        
        // ===== CHART RESIZE HANDLING =====
        
        /**
         * Handle chart resize events
         */
        function handleChartResize() {
            if (chart) {
                chart.resize();
            }
            if (maximizedChart) {
                maximizedChart.resize();
            }
        }
        
        // ===== CHART THEME SUPPORT =====
        
        /**
         * Apply dark theme to charts
         */
        function applyDarkTheme() {
            // Update text styles for dark theme
            textStyles.dataLabels.color = '#e0e0e0';
            textStyles.axisLabels.color = '#b0b0b0';
            textStyles.functionNames.color = '#e0e0e0';
            textStyles.categoryLabels.color = '#e0e0e0';
            textStyles.title.color = '#e0e0e0';
            textStyles.legend.color = '#e0e0e0';
            
            // Recreate charts with new theme
            createCharts();
        }
        
        /**
         * Apply light theme to charts
         */
        function applyLightTheme() {
            // Update text styles for light theme
            textStyles.dataLabels.color = '#333333';
            textStyles.axisLabels.color = '#666666';
            textStyles.functionNames.color = '#333333';
            textStyles.categoryLabels.color = '#333333';
            textStyles.title.color = '#333333';
            textStyles.legend.color = '#333333';
            
            // Recreate charts with new theme
            createCharts();
        }
        
        /**
         * Detect and apply system theme preference
         */
        function applySystemTheme() {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                applyDarkTheme();
            } else {
                applyLightTheme();
            }
        }
        
        // ===== CHART ANIMATION HELPERS =====
        
        /**
         * Create custom animation for chart updates
         * @param {Function} updateFunction - Function to call during animation
         * @param {number} duration - Animation duration in milliseconds
         */
        function animateChartUpdate(updateFunction, duration = 750) {
            const startTime = performance.now();
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easing function
                const easeInOut = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                updateFunction(easeInOut);
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // ===== CHART INTERACTION HELPERS =====
        
        /**
         * Add click handlers to chart elements
         * @param {Chart} chartInstance - Chart.js instance
         */
        function addChartInteractions(chartInstance) {
            if (!chartInstance || !chartInstance.canvas) return;
            
            chartInstance.canvas.addEventListener('click', function(event) {
                const points = chartInstance.getElementsAtEventForMode(
                    event, 
                    'nearest', 
                    { intersect: true }, 
                    true
                );
                
                if (points.length > 0) {
                    const point = points[0];
                    const datasetIndex = point.datasetIndex;
                    const index = point.index;
                    const dataset = chartInstance.data.datasets[datasetIndex];
                    
                    // Handle click on chart element
                    console.log('Clicked on:', {
                        dataset: dataset.label,
                        value: dataset.data[index],
                        index: index
                    });
                    
                    // Could implement drill-down functionality here
                }
            });
            
            // Add hover effects
            chartInstance.canvas.addEventListener('mousemove', function(event) {
                const points = chartInstance.getElementsAtEventForMode(
                    event, 
                    'nearest', 
                    { intersect: true }, 
                    true
                );
                
                chartInstance.canvas.style.cursor = points.length > 0 ? 'pointer' : 'default';
            });
        }
        
        // ===== GLOBAL ERROR HANDLING =====
        
        /**
         * Global error handler for chart-related errors
         */
        window.addEventListener('error', function(event) {
            if (event.error && event.error.message && 
                (event.error.message.includes('Chart') || event.error.message.includes('canvas'))) {
                console.error('Chart-related global error:', event.error);
                handleChartError(event.error, 'global chart error');
            }
        });
        
        /**
         * Handle unhandled promise rejections in chart operations
         */
        window.addEventListener('unhandledrejection', function(event) {
            if (event.reason && event.reason.message && 
                (event.reason.message.includes('Chart') || event.reason.message.includes('canvas'))) {
                console.error('Chart-related promise rejection:', event.reason);
                handleChartError(event.reason, 'chart promise rejection');
                event.preventDefault(); // Prevent the default unhandled rejection behavior
            }
        });
        
        // ===== EXPOSED FUNCTIONS FOR DEBUGGING =====
        
        /**
         * Expose chart functions for debugging and testing
         */
        window.chartDebug = {
            validateChartData: validateChartData,
            recreateCharts: createCharts,
            exportAsCSV: exportChartDataAsCSV,
            exportAsJSON: exportChartDataAsJSON,
            cleanup: cleanup,
            getChartState: () => ({
                chart: chart,
                maximizedChart: maximizedChart,
                exportedImages: exportedImages
            }),
            applyDarkTheme: applyDarkTheme,
            applyLightTheme: applyLightTheme
        };
        
        /* ===========================================
           END OF PART 5: CHART CREATION & ADVANCED FEATURES
           =========================================== */
        /* ===========================================
           PART 6: INITIALIZATION & GLOBAL SETUP
           =========================================== */
        
        // ===== INITIALIZATION SEQUENCE =====
        
        /**
         * Main dashboard initialization function
         * Coordinates the startup of all dashboard components
         */
        function initializeDashboard() {
            try {
                console.log('Starting dashboard initialization...');
                
                // Phase 1: Core data initialization
                initializeCoreData();
                
                // Phase 2: Browser compatibility check
                const compatibility = checkBrowserCompatibility();
                if (!compatibility.compatible) {
                    console.warn('Browser compatibility issues detected:', compatibility.missing);
                }
                
                // Phase 3: UI components initialization
                initializeUI();
                
                // Phase 4: Event handlers setup
                initializeAllEventHandlers();
                
                // Phase 5: Chart system initialization
                initializeChartSystem();
                
                // Phase 6: Accessibility setup
                initializeAccessibility();
                
                // Phase 7: Performance optimization
                optimizeInitialPerformance();
                
                // Phase 8: Final setup and announcements
                finalizeInitialization();
                
                console.log('Dashboard initialization completed successfully');
                
            } catch (error) {
                console.error('Critical error during dashboard initialization:', error);
                handleInitializationError(error);
            }
        }
        
        /**
         * Initialize core data structures and default values
         */
        function initializeCoreData() {
            console.log('Initializing core data structures...');
            
            try {
                // Ensure data integrity
                const validation = validateDataIntegrity();
                if (!validation.valid) {
                    console.warn('Data integrity issues found:', validation.issues);
                    // Attempt to repair data
                    repairDataStructure();
                }
                
                // Initialize trend line configurations
                initializeTrendLineConfig();
                
                // Set up default axis configurations
                initializeAxisConfig();
                
                // Initialize text styles with system preferences
                initializeTextStyles();
                
                // Set up initial spacing values
                initializeSpacingConfig();
                
                console.log('Core data initialization complete');
                
            } catch (error) {
                console.error('Error initializing core data:', error);
                // Fall back to minimal safe defaults
                resetToDefaults();
            }
        }
        
        /**
         * Initialize axis configuration with safe defaults
         */
        function initializeAxisConfig() {
            if (!axisConfig.primary) {
                axisConfig.primary = {
                    min: null,
                    max: null,
                    autoMin: true,
                    autoMax: true
                };
            }
            
            if (!axisConfig.secondary) {
                axisConfig.secondary = {
                    min: 0,
                    max: 100,
                    autoMin: false,
                    autoMax: false
                };
            }
        }
        
        /**
         * Initialize text styles with system preferences
         */
        function initializeTextStyles() {
            // Detect system theme preference
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            if (prefersDark) {
                // Apply dark theme colors
                textStyles.dataLabels.color = '#e0e0e0';
                textStyles.axisLabels.color = '#b0b0b0';
                textStyles.functionNames.color = '#e0e0e0';
                textStyles.categoryLabels.color = '#e0e0e0';
                textStyles.title.color = '#e0e0e0';
                textStyles.legend.color = '#e0e0e0';
            }
            
            // Detect system font size preferences
            const fontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
            if (fontSize !== 16) {
                // Adjust font sizes based on system preference
                const scaleFactor = fontSize / 16;
                Object.keys(textStyles).forEach(key => {
                    if (textStyles[key].fontSize) {
                        textStyles[key].fontSize = Math.round(textStyles[key].fontSize * scaleFactor);
                    }
                });
            }
        }
        
        /**
         * Initialize spacing configuration
         */
        function initializeSpacingConfig() {
            // Ensure spacing values are within valid ranges
            columnSpacing = Math.max(0, Math.min(5, columnSpacing));
            categoryGap = Math.max(1, Math.min(8, categoryGap));
        }
        
        /**
         * Repair corrupted data structures
         */
        function repairDataStructure() {
            console.log('Attempting to repair data structure...');
            
            // Ensure all functions have data for all years and categories
            functions.forEach(func => {
                if (!functionData[func.id]) {
                    functionData[func.id] = {};
                }
                
                years.forEach(year => {
                    if (!functionData[func.id][year.id]) {
                        functionData[func.id][year.id] = new Array(categories.length).fill(0);
                    } else if (functionData[func.id][year.id].length !== categories.length) {
                        // Resize array to match categories
                        const currentLength = functionData[func.id][year.id].length;
                        if (currentLength < categories.length) {
                            // Pad with zeros
                            functionData[func.id][year.id] = [
                                ...functionData[func.id][year.id],
                                ...new Array(categories.length - currentLength).fill(0)
                            ];
                        } else {
                            // Trim excess
                            functionData[func.id][year.id] = functionData[func.id][year.id].slice(0, categories.length);
                        }
                    }
                });
            });
            
            // Ensure all categories have trend line configurations
            categories.forEach(category => {
                if (!trendLineConfig[category.id]) {
                    trendLineConfig[category.id] = {
                        enabled: true,
                        color: category.color,
                        thickness: 2,
                        pointSize: 4,
                        opacity: 1.0,
                        showPoints: true,
                        showLine: true,
                        complementaryColor: darkenColor(category.color, 20)
                    };
                }
            });
            
            console.log('Data structure repair completed');
        }
        
        // ===== ACCESSIBILITY INITIALIZATION =====
        
        /**
         * Initialize accessibility features
         */
        function initializeAccessibility() {
            console.log('Setting up accessibility features...');
            
            try {
                // Create announcement region if it doesn't exist
                if (!document.getElementById('announcement')) {
                    const announcement = document.createElement('div');
                    announcement.id = 'announcement';
                    announcement.className = 'sr-only';
                    announcement.setAttribute('aria-live', 'polite');
                    announcement.setAttribute('aria-atomic', 'true');
                    announcement.setAttribute('role', 'status');
                    document.body.appendChild(announcement);
                }
                
                // Set up focus management
                setupFocusManagement();
                
                // Initialize keyboard navigation
                setupKeyboardNavigation();
                
                // Set up screen reader enhancements
                setupScreenReaderEnhancements();
                
                // Initialize high contrast support
                setupHighContrastSupport();
                
                // Set up reduced motion support
                setupReducedMotionSupport();
                
                console.log('Accessibility setup complete');
                
            } catch (error) {
                console.error('Error setting up accessibility:', error);
            }
        }
        
        /**
         * Setup focus management for accessibility
         */
        function setupFocusManagement() {
            // Add focus indicators to interactive elements
            const style = document.createElement('style');
            style.textContent = `
                .focus-indicator:focus {
                    outline: 3px solid #667eea !important;
                    outline-offset: 2px !important;
                }
                
                .skip-to-content:focus {
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    z-index: 10000;
                    background: #667eea;
                    color: white;
                    padding: 10px;
                    text-decoration: none;
                    border-radius: 4px;
                }
            `;
            document.head.appendChild(style);
            
            // Add focus indicators to relevant elements
            document.querySelectorAll('button, input, select, [tabindex], [role="button"]').forEach(el => {
                if (!el.classList.contains('focus-indicator')) {
                    el.classList.add('focus-indicator');
                }
            });
        }
        
        /**
         * Setup keyboard navigation
         */
        function setupKeyboardNavigation() {
            // Add keyboard navigation to chart
            const chartCanvas = document.getElementById('qaChart');
            if (chartCanvas) {
                chartCanvas.setAttribute('tabindex', '0');
                chartCanvas.setAttribute('role', 'img');
                
                chartCanvas.addEventListener('keydown', function(e) {
                    switch (e.key) {
                        case 'ArrowLeft':
                        case 'ArrowRight':
                        case 'ArrowUp':
                        case 'ArrowDown':
                            e.preventDefault();
                            // Could implement chart navigation here
                            announceChange(`Navigating chart with ${e.key}`);
                            break;
                        case 'Enter':
                        case ' ':
                            e.preventDefault();
                            // Could implement chart interaction here
                            announceChange('Chart element activated');
                            break;
                    }
                });
            }
            
            // Add ARIA landmarks to main sections
            const main = document.getElementById('main-content');
            if (main) {
                main.setAttribute('role', 'main');
                main.setAttribute('aria-label', 'Main dashboard content');
            }
            
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                sidebar.setAttribute('role', 'complementary');
                sidebar.setAttribute('aria-label', 'Dashboard configuration panel');
            }
        }
        
        /**
         * Setup screen reader enhancements
         */
        function setupScreenReaderEnhancements() {
            // Add descriptive labels to form controls
            document.querySelectorAll('input, select').forEach(input => {
                if (!input.getAttribute('aria-label') && !input.getAttribute('aria-labelledby')) {
                    const label = input.closest('.control-group')?.querySelector('label');
                    if (label) {
                        const labelId = 'label-' + Math.random().toString(36).substr(2, 9);
                        label.id = labelId;
                        input.setAttribute('aria-labelledby', labelId);
                    }
                }
            });
            
            // Add live region for dynamic content updates
            const liveRegion = document.createElement('div');
            liveRegion.id = 'live-region';
            liveRegion.setAttribute('aria-live', 'assertive');
            liveRegion.setAttribute('aria-atomic', 'true');
            liveRegion.className = 'sr-only';
            document.body.appendChild(liveRegion);
        }
        
        /**
         * Setup high contrast support
         */
        function setupHighContrastSupport() {
            if (window.matchMedia) {
                const highContrastQuery = window.matchMedia('(prefers-high-contrast: active)');
                
                function handleHighContrastChange(e) {
                    if (e.matches) {
                        document.body.classList.add('high-contrast');
                        // Apply high contrast styles
                        applyHighContrastMode();
                    } else {
                        document.body.classList.remove('high-contrast');
                    }
                }
                
                // Check initial state
                handleHighContrastChange(highContrastQuery);
                
                // Listen for changes
                if (highContrastQuery.addListener) {
                    highContrastQuery.addListener(handleHighContrastChange);
                } else {
                    highContrastQuery.addEventListener('change', handleHighContrastChange);
                }
            }
        }
        
        /**
         * Apply high contrast mode styles
         */
        function applyHighContrastMode() {
            const style = document.createElement('style');
            style.id = 'high-contrast-styles';
            style.textContent = `
                .high-contrast * {
                    border-color: CanvasText !important;
                }
                
                .high-contrast .chart-container,
                .high-contrast .function-input,
                .high-contrast .item {
                    border-width: 3px !important;
                }
                
                .high-contrast input,
                .high-contrast select,
                .high-contrast button {
                    border-width: 2px !important;
                    border-color: CanvasText !important;
                }
            `;
            document.head.appendChild(style);
        }
        
        /**
         * Setup reduced motion support
         */
        function setupReducedMotionSupport() {
            if (window.matchMedia) {
                const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
                
                function handleReducedMotionChange(e) {
                    if (e.matches) {
                        document.body.classList.add('reduced-motion');
                        // Disable animations
                        const animationSelect = document.getElementById('animation');
                        if (animationSelect) {
                            animationSelect.value = 'false';
                            announceChange('Animations disabled due to motion preference');
                        }
                    } else {
                        document.body.classList.remove('reduced-motion');
                    }
                }
                
                // Check initial state
                handleReducedMotionChange(reducedMotionQuery);
                
                // Listen for changes
                if (reducedMotionQuery.addListener) {
                    reducedMotionQuery.addListener(handleReducedMotionChange);
                } else {
                    reducedMotionQuery.addEventListener('change', handleReducedMotionChange);
                }
            }
        }
        
        // ===== PERFORMANCE OPTIMIZATION =====
        
        /**
         * Optimize initial performance
         */
        function optimizeInitialPerformance() {
            console.log('Optimizing initial performance...');
            
            try {
                // Defer non-critical operations
                setTimeout(() => {
                    optimizeDataStructures();
                    setupIntersectionObserver();
                    preloadCriticalResources();
                }, 100);
                
                // Setup performance monitoring
                setupPerformanceMonitoring();
                
                // Initialize lazy loading for non-visible elements
                setupLazyLoading();
                
                console.log('Performance optimization complete');
                
            } catch (error) {
                console.error('Error during performance optimization:', error);
            }
        }
        
        /**
         * Setup performance monitoring
         */
        function setupPerformanceMonitoring() {
            if ('performance' in window) {
                // Monitor chart creation performance
                const originalCreateCharts = createCharts;
                window.createCharts = function() {
                    const startTime = performance.now();
                    const result = originalCreateCharts.apply(this, arguments);
                    const endTime = performance.now();
                    
                    console.log(`Chart creation took ${endTime - startTime} milliseconds`);
                    
                    // If chart creation is slow, suggest optimizations
                    if (endTime - startTime > 1000) {
                        console.warn('Chart creation is slow. Consider disabling animations or reducing data complexity.');
                    }
                    
                    return result;
                };
            }
        }
        
        /**
         * Setup lazy loading for non-critical elements
         */
        function setupLazyLoading() {
            // Lazy load chart creation until dashboard is visible
            if ('IntersectionObserver' in window) {
                const chartContainer = document.getElementById('chartContainer');
                if (chartContainer) {
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                // Chart container is visible, safe to create charts
                                setTimeout(() => createCharts(), 50);
                                observer.unobserve(entry.target);
                            }
                        });
                    }, { threshold: 0.1 });
                    
                    observer.observe(chartContainer);
                }
            } else {
                // Fallback for browsers without IntersectionObserver
                setTimeout(() => createCharts(), 200);
            }
        }
        
        /**
         * Preload critical resources
         */
        function preloadCriticalResources() {
            // Preload any critical fonts or assets
            const fontLink = document.createElement('link');
            fontLink.rel = 'preload';
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap';
            fontLink.as = 'style';
            fontLink.onload = function() {
                this.onload = null;
                this.rel = 'stylesheet';
            };
            document.head.appendChild(fontLink);
        }
        
        // ===== ERROR HANDLING =====
        
        /**
         * Handle initialization errors
         * @param {Error} error - Error that occurred during initialization
         */
        function handleInitializationError(error) {
            console.error('Dashboard initialization failed:', error);
            
            // Show user-friendly error message
            const errorContainer = document.createElement('div');
            errorContainer.className = 'initialization-error';
            errorContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                font-family: Arial, sans-serif;
            `;
            
            errorContainer.innerHTML = `
                <div style="background: #f44336; padding: 40px; border-radius: 8px; max-width: 500px; text-align: center;">
                    <h2 style="margin: 0 0 20px 0;">Dashboard Initialization Failed</h2>
                    <p style="margin: 0 0 20px 0;">
                        There was an error starting the dashboard. This could be due to:
                    </p>
                    <ul style="text-align: left; margin: 20px 0;">
                        <li>Browser compatibility issues</li>
                        <li>Missing required libraries</li>
                        <li>Network connectivity problems</li>
                    </ul>
                    <div style="margin-top: 30px;">
                        <button onclick="location.reload()" 
                                style="background: white; color: #f44336; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                            Retry
                        </button>
                        <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                                style="background: transparent; color: white; border: 2px solid white; padding: 8px 18px; border-radius: 4px; cursor: pointer;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(errorContainer);
            
            // Try to initialize in safe mode
            setTimeout(() => {
                try {
                    console.log('Attempting safe mode initialization...');
                    initializeSafeMode();
                } catch (safeError) {
                    console.error('Safe mode initialization also failed:', safeError);
                }
            }, 1000);
        }
        
        /**
         * Initialize dashboard in safe mode with minimal functionality
         */
        function initializeSafeMode() {
            console.log('Initializing dashboard in safe mode...');
            
            try {
                // Reset to absolute minimal defaults
                resetToDefaults();
                
                // Disable all animations
                const animationSelect = document.getElementById('animation');
                if (animationSelect) {
                    animationSelect.value = 'false';
                }
                
                // Basic UI rendering only
                renderAllComponents();
                
                // Show safe mode indicator
                const indicator = document.createElement('div');
                indicator.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    background: #ff9800;
                    color: white;
                    padding: 10px;
                    border-radius: 4px;
                    z-index: 1000;
                    font-size: 12px;
                `;
                indicator.textContent = 'Running in Safe Mode';
                document.body.appendChild(indicator);
                
                console.log('Safe mode initialization completed');
                
            } catch (error) {
                console.error('Safe mode initialization failed:', error);
            }
        }
        
        // ===== FINALIZATION =====
        
        /**
         * Finalize dashboard initialization
         */
        function finalizeInitialization() {
            console.log('Finalizing dashboard initialization...');
            
            try {
                // Update all display values
                updateTextStyleDisplays();
                updateShadingPreview();
                updateSpacingControls();
                
                // Set initial states
                toggleDataLabelOptions();
                toggleManualOpacityControls();
                
                // Apply system theme if supported
                if (window.matchMedia) {
                    applySystemTheme();
                }
                
                // Setup theme change listeners
                setupThemeChangeListeners();
                
                // Mark dashboard as ready
                document.body.classList.add('dashboard-ready');
                document.body.setAttribute('data-dashboard-status', 'ready');
                
                // Announce completion
                announceChange('Dashboard loaded and ready for use');
                
                // Fire custom ready event
                const readyEvent = new CustomEvent('dashboardReady', {
                    detail: {
                        timestamp: new Date(),
                        version: '2.0',
                        features: {
                            charts: true,
                            accessibility: true,
                            responsive: true,
                            themes: true
                        }
                    }
                });
                window.dispatchEvent(readyEvent);
                
                console.log('Dashboard initialization finalized successfully');
                
            } catch (error) {
                console.error('Error during finalization:', error);
            }
        }
        
        /**
         * Setup theme change listeners
         */
        function setupThemeChangeListeners() {
            if (window.matchMedia) {
                const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');
                
                function handleThemeChange(e) {
                    if (e.matches) {
                        applyDarkTheme();
                    } else {
                        applyLightTheme();
                    }
                    announceChange(`Theme changed to ${e.matches ? 'dark' : 'light'} mode`);
                }
                
                if (darkModeQuery.addListener) {
                    darkModeQuery.addListener(handleThemeChange);
                } else {
                    darkModeQuery.addEventListener('change', handleThemeChange);
                }
            }
        }
        
        // ===== WINDOW EVENTS =====
        
        /**
         * Setup window-level event handlers
         */
        function setupWindowEvents() {
            // Page load event
            window.addEventListener('load', function() {
                console.log('Window load event fired');
                // Additional initialization that requires full page load
                setTimeout(() => {
                    optimizeInitialPerformance();
                }, 100);
            });
            
            // Before unload event
            window.addEventListener('beforeunload', function(e) {
                // Check for unsaved changes
                const hasActiveEdits = functions.some(f => f.editable) || 
                                     categories.some(c => c.editable) || 
                                     years.some(y => y.editable);
                
                if (hasActiveEdits) {
                    const message = 'You have unsaved changes. Are you sure you want to leave?';
                    e.returnValue = message;
                    return message;
                }
                
                // Cleanup
                cleanup();
                cleanupUI();
                cleanupEventHandlers();
            });
            
            // Visibility change event
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    // Page is hidden - pause non-essential operations
                    if (updateTimeout) {
                        clearTimeout(updateTimeout);
                    }
                } else {
                    // Page is visible - resume operations
                    if (chart && typeof chart.resize === 'function') {
                        chart.resize();
                    }
                }
            });
            
            // Online/offline events
            window.addEventListener('online', function() {
                announceChange('Connection restored');
                console.log('Dashboard: Connection restored');
            });
            
            window.addEventListener('offline', function() {
                announceChange('Connection lost - working offline');
                console.log('Dashboard: Working offline');
            });
        }
        
        // ===== MAIN INITIALIZATION TRIGGER =====
        
        /**
         * Initialize dashboard when DOM is ready
         */
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM content loaded, starting dashboard initialization...');
            
            // Small delay to ensure all resources are ready
            setTimeout(() => {
                initializeDashboard();
                setupWindowEvents();
            }, 50);
        });
        
        // ===== LEGACY BROWSER SUPPORT =====
        
        /**
         * Provide fallbacks for older browsers
         */
        (function() {
            // CustomEvent polyfill for IE
            if (typeof window.CustomEvent !== 'function') {
                function CustomEvent(event, params) {
                    params = params || { bubbles: false, cancelable: false, detail: null };
                    var evt = document.createEvent('CustomEvent');
                    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
                    return evt;
                }
                window.CustomEvent = CustomEvent;
            }
            
            // Array.from polyfill
            if (!Array.from) {
                Array.from = function(arrayLike) {
                    return Array.prototype.slice.call(arrayLike);
                };
            }
            
            // Object.assign polyfill
            if (!Object.assign) {
                Object.assign = function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) {
                            if (source.hasOwnProperty(key)) {
                                target[key] = source[key];
                            }
                        }
                    }
                    return target;
                };
            }
        })();
        
        // ===== GLOBAL ERROR HANDLERS =====
        
        /**
         * Global error handler
         */
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            
            // Don't show error for chart-related errors (handled separately)
            if (!event.error?.message?.includes('Chart')) {
                handleInitializationError(event.error);
            }
        });
        
        /**
         * Unhandled promise rejection handler
         */
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            
            // Prevent the default behavior
            event.preventDefault();
            
            // Handle the error gracefully
            if (typeof event.reason === 'object' && event.reason.message) {
                console.error('Promise rejection details:', event.reason.message);
            }
        });
        
        // ===== DEBUG MODE =====
        
        /**
         * Enable debug mode for development
         */
        if (window.location.search.includes('debug=true')) {
            window.dashboardDebugMode = true;
            console.log('Dashboard debug mode enabled');
            
            // Expose additional debugging functions
            window.dashboardDebugGlobal = {
                initializeDashboard,
                initializeSafeMode,
                validateDataIntegrity,
                resetToDefaults,
                exportDashboardData,
                importDashboardData,
                debugLogData,
                getUIState,
                restoreUIState
            };
        }
        
        /* ===========================================
           END OF PART 6: INITIALIZATION & GLOBAL SETUP
           =========================================== */
        /* ===========================================
           PART 7: EXPORT/IMPORT & UTILITY FUNCTIONS
           =========================================== */
        
        // ===== DATA EXPORT FUNCTIONS =====
        
        /**
         * Export complete dashboard configuration and data as JSON
         * @returns {string} JSON string of complete dashboard state
         */
        function exportDashboardData() {
            try {
                const dashboardState = {
                    version: '2.0',
                    timestamp: new Date().toISOString(),
                    metadata: {
                        exportCount: exportCounter,
                        totalFunctions: functions.length,
                        totalCategories: categories.length,
                        totalYears: years.length,
                        browser: navigator.userAgent,
                        url: window.location.href
                    },
                    configuration: {
                        years: years.map(y => ({ ...y, editable: false })), // Remove edit states
                        categories: categories.map(c => ({ ...c, editable: false })),
                        functions: functions.map(f => ({ ...f, editable: false })),
                        functionData: functionData,
                        textStyles: textStyles,
                        trendLineConfig: trendLineConfig,
                        columnSpacing: columnSpacing,
                        categoryGap: categoryGap,
                        axisConfig: axisConfig
                    },
                    uiState: getUIState(),
                    chartSettings: {
                        chartType: document.getElementById('chartType')?.value || 'bar',
                        animation: document.getElementById('animation')?.value === 'true',
                        sortBy: document.getElementById('sortBy')?.value || 'default',
                        sortDirection: document.getElementById('sortDirection')?.value || 'asc',
                        showDataLabels: document.getElementById('showDataLabels')?.checked || false,
                        showValues: document.getElementById('showValues')?.checked || false,
                        showPercentages: document.getElementById('showPercentages')?.checked || false,
                        showTrendLine: document.getElementById('showTrendLine')?.checked || false
                    }
                };
                
                return JSON.stringify(dashboardState, null, 2);
                
            } catch (error) {
                console.error('Error exporting dashboard data:', error);
                showToast('Failed to export dashboard data', 'error');
                return null;
            }
        }
        
        /**
         * Export dashboard data as a downloadable JSON file
         */
        function downloadDashboardData() {
            try {
                const jsonData = exportDashboardData();
                if (!jsonData) return;
                
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const filename = `dashboard_export_${timestamp}.json`;
                
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                showToast(`Dashboard exported as ${filename}`, 'success');
                announceChange(`Dashboard exported as ${filename}`);
                
            } catch (error) {
                console.error('Error downloading dashboard data:', error);
                showToast('Failed to download dashboard data', 'error');
            }
        }
        
        /**
         * Export chart data as CSV format
         * @returns {string} CSV formatted data
         */
        function exportChartDataAsCSV() {
            try {
                const prevYear = getPreviousYear();
                const currYear = getCurrentYear();
                
                if (!prevYear || !currYear) {
                    throw new Error('Missing year configuration');
                }
                
                let csv = 'Function';
                
                // Add category headers for both years
                categories.forEach(category => {
                    csv += `,${category.name} ${prevYear.name},${category.name} ${currYear.name}`;
                });
                
                // Add percentage headers
                categories.forEach(category => {
                    csv += `,${category.name} ${prevYear.name} %,${category.name} ${currYear.name} %`;
                });
                
                // Add total headers
                csv += `,Total ${prevYear.name},Total ${currYear.name}`;
                csv += '\n';
                
                // Add data rows
                functions.forEach(func => {
                    csv += func.name;
                    
                    // Add raw values
                    categories.forEach((category, catIndex) => {
                        const prevValue = getDataValue(func.id, prevYear.id, catIndex);
                        const currValue = getDataValue(func.id, currYear.id, catIndex);
                        csv += `,${prevValue},${currValue}`;
                    });
                    
                    // Add percentages
                    categories.forEach((category, catIndex) => {
                        const prevPerc = getCategoryPercentage(func.id, prevYear.id, catIndex);
                        const currPerc = getCategoryPercentage(func.id, currYear.id, catIndex);
                        csv += `,${prevPerc.toFixed(2)},${currPerc.toFixed(2)}`;
                    });
                    
                    // Add totals
                    const prevTotal = getFunctionYearTotal(func.id, prevYear.id);
                    const currTotal = getFunctionYearTotal(func.id, currYear.id);
                    csv += `,${prevTotal},${currTotal}`;
                    
                    csv += '\n';
                });
                
                return csv;
                
            } catch (error) {
                console.error('Error exporting CSV data:', error);
                showToast('Failed to export CSV data', 'error');
                return null;
            }
        }
        
        /**
         * Download chart data as CSV file
         */
        function downloadChartDataAsCSV() {
            try {
                const csvData = exportChartDataAsCSV();
                if (!csvData) return;
                
                const blob = new Blob([csvData], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const filename = `chart_data_${timestamp}.csv`;
                
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                showToast(`Chart data exported as ${filename}`, 'success');
                announceChange(`Chart data exported as ${filename}`);
                
            } catch (error) {
                console.error('Error downloading CSV data:', error);
                showToast('Failed to download CSV data', 'error');
            }
        }
        
        /**
         * Export summary report as formatted text
         * @returns {string} Formatted summary report
         */
        function exportSummaryReport() {
            try {
                const prevYear = getPreviousYear();
                const currYear = getCurrentYear();
                
                if (!prevYear || !currYear) {
                    throw new Error('Missing year configuration');
                }
                
                let report = `Quality Assurance Review Results Summary\n`;
                report += `Generated: ${new Date().toLocaleString()}\n`;
                report += `Comparison: ${prevYear.name} vs ${currYear.name}\n`;
                report += `${'='.repeat(50)}\n\n`;
                
                // Overall statistics
                let totalPrev = 0, totalCurr = 0;
                let totalPassPrev = 0, totalPassCurr = 0;
                
                functions.forEach(func => {
                    const funcTotalPrev = getFunctionYearTotal(func.id, prevYear.id);
                    const funcTotalCurr = getFunctionYearTotal(func.id, currYear.id);
                    const funcPassPrev = getDataValue(func.id, prevYear.id, 0);
                    const funcPassCurr = getDataValue(func.id, currYear.id, 0);
                    
                    totalPrev += funcTotalPrev;
                    totalCurr += funcTotalCurr;
                    totalPassPrev += funcPassPrev;
                    totalPassCurr += funcPassCurr;
                });
                
                const passRatePrev = totalPrev > 0 ? (totalPassPrev / totalPrev * 100) : 0;
                const passRateCurr = totalCurr > 0 ? (totalPassCurr / totalCurr * 100) : 0;
                const passRateChange = passRateCurr - passRatePrev;
                
                report += `OVERALL SUMMARY\n`;
                report += `${'-'.repeat(20)}\n`;
                report += `Total Reviews ${prevYear.name}: ${totalPrev}\n`;
                report += `Total Reviews ${currYear.name}: ${totalCurr}\n`;
                report += `Volume Change: ${totalCurr - totalPrev} (${((totalCurr - totalPrev) / totalPrev * 100).toFixed(1)}%)\n\n`;
                report += `Pass Rate ${prevYear.name}: ${passRatePrev.toFixed(1)}%\n`;
                report += `Pass Rate ${currYear.name}: ${passRateCurr.toFixed(1)}%\n`;
                report += `Pass Rate Change: ${passRateChange >= 0 ? '+' : ''}${passRateChange.toFixed(1)} percentage points\n\n`;
                
                // Function-level details
                report += `FUNCTION BREAKDOWN\n`;
                report += `${'-'.repeat(20)}\n`;
                
                functions.forEach(func => {
                    report += `\n${func.name.toUpperCase()}\n`;
                    
                    const funcTotalPrev = getFunctionYearTotal(func.id, prevYear.id);
                    const funcTotalCurr = getFunctionYearTotal(func.id, currYear.id);
                    
                    report += `  Reviews: ${funcTotalPrev}  ${funcTotalCurr}\n`;
                    
                    categories.forEach((category, catIndex) => {
                        const prevValue = getDataValue(func.id, prevYear.id, catIndex);
                        const currValue = getDataValue(func.id, currYear.id, catIndex);
                        const prevPerc = getCategoryPercentage(func.id, prevYear.id, catIndex);
                        const currPerc = getCategoryPercentage(func.id, currYear.id, catIndex);
                        const change = currPerc - prevPerc;
                        
                        report += `  ${category.name}: ${prevValue} (${prevPerc.toFixed(1)}%)  ${currValue} (${currPerc.toFixed(1)}%) [${change >= 0 ? '+' : ''}${change.toFixed(1)}pp]\n`;
                    });
                });
                
                // Best/worst performers
                report += `\nPERFORMANCE ANALYSIS\n`;
                report += `${'-'.repeat(20)}\n`;
                
                const improvements = functions.map(func => ({
                    name: func.name,
                    improvement: getYearOverYearChange(func.id, 0) // Pass rate change
                })).sort((a, b) => b.improvement - a.improvement);
                
                report += `Best Improvement: ${improvements[0].name} (+${improvements[0].improvement.toFixed(1)}pp)\n`;
                report += `Needs Attention: ${improvements[improvements.length - 1].name} (${improvements[improvements.length - 1].improvement.toFixed(1)}pp)\n`;
                
                return report;
                
            } catch (error) {
                console.error('Error generating summary report:', error);
                showToast('Failed to generate summary report', 'error');
                return null;
            }
        }
        
        /**
         * Download summary report as text file
         */
        function downloadSummaryReport() {
            try {
                const reportData = exportSummaryReport();
                if (!reportData) return;
                
                const blob = new Blob([reportData], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                const filename = `qa_summary_report_${timestamp}.txt`;
                
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                showToast(`Summary report exported as ${filename}`, 'success');
                announceChange(`Summary report exported as ${filename}`);
                
            } catch (error) {
                console.error('Error downloading summary report:', error);
                showToast('Failed to download summary report', 'error');
            }
        }
        
        // ===== DATA IMPORT FUNCTIONS =====
        
        /**
         * Import dashboard configuration from JSON data
         * @param {string} jsonData - JSON string containing dashboard state
         * @returns {Object} Import result with success status and any errors
         */
        function importDashboardData(jsonData) {
            try {
                const dashboardState = JSON.parse(jsonData);
                
                // Validate data structure
                if (!dashboardState.configuration) {
                    throw new Error('Invalid data format: missing configuration');
                }
                
                const config = dashboardState.configuration;
                const errors = [];
                
                // Validate required arrays
                if (!Array.isArray(config.years) || config.years.length === 0) {
                    errors.push('Invalid or empty years array');
                }
                
                if (!Array.isArray(config.categories) || config.categories.length === 0) {
                    errors.push('Invalid or empty categories array');
                }
                
                if (!Array.isArray(config.functions) || config.functions.length === 0) {
                    errors.push('Invalid or empty functions array');
                }
                
                if (errors.length > 0) {
                    return { success: false, errors: errors };
                }
                
                // Backup current state
                const backup = {
                    years: [...years],
                    categories: [...categories],
                    functions: [...functions],
                    functionData: { ...functionData },
                    textStyles: { ...textStyles },
                    trendLineConfig: { ...trendLineConfig },
                    columnSpacing: columnSpacing,
                    categoryGap: categoryGap,
                    axisConfig: { ...axisConfig }
                };
                
                try {
                    // Import data with validation
                    if (config.years) {
                        years = config.years.map(y => ({ ...y, editable: false }));
                    }
                    if (config.categories) {
                        categories = config.categories.map(c => ({ ...c, editable: false }));
                    }
                    if (config.functions) {
                        functions = config.functions.map(f => ({ ...f, editable: false }));
                    }
                    if (config.functionData && typeof config.functionData === 'object') {
                        functionData = config.functionData;
                    }
                    if (config.textStyles && typeof config.textStyles === 'object') {
                        textStyles = { ...textStyles, ...config.textStyles };
                    }
                    if (config.trendLineConfig && typeof config.trendLineConfig === 'object') {
                        trendLineConfig = { ...trendLineConfig, ...config.trendLineConfig };
                    }
                    if (typeof config.columnSpacing === 'number') {
                        columnSpacing = config.columnSpacing;
                    }
                    if (typeof config.categoryGap === 'number') {
                        categoryGap = config.categoryGap;
                    }
                    if (config.axisConfig && typeof config.axisConfig === 'object') {
                        axisConfig = { ...axisConfig, ...config.axisConfig };
                    }
                    
                    // Restore UI state if available
                    if (dashboardState.uiState) {
                        restoreUIState(dashboardState.uiState);
                    }
                    
                    // Restore chart settings if available
                    if (dashboardState.chartSettings) {
                        restoreChartSettings(dashboardState.chartSettings);
                    }
                    
                    // Validate imported data
                    const validation = validateDataIntegrity();
                    if (!validation.valid) {
                        console.warn('Imported data has integrity issues:', validation.issues);
                        repairDataStructure();
                    }
                    
                    // Re-render everything
                    renderAllComponents();
                    createCharts();
                    
                    return { success: true, errors: [], backup: backup };
                    
                } catch (importError) {
                    // Restore backup on error
                    years = backup.years;
                    categories = backup.categories;
                    functions = backup.functions;
                    functionData = backup.functionData;
                    textStyles = backup.textStyles;
                    trendLineConfig = backup.trendLineConfig;
                    columnSpacing = backup.columnSpacing;
                    categoryGap = backup.categoryGap;
                    axisConfig = backup.axisConfig;
                    
                    throw importError;
                }
                
            } catch (error) {
                console.error('Error importing dashboard data:', error);
                return { success: false, errors: [error.message] };
            }
        }
        
        /**
         * Handle file import from user input
         * @param {File} file - File object from input
         */
        function importFromFile(file) {
            if (!file) {
                showToast('No file selected', 'warning');
                return;
            }
            
            if (!file.name.toLowerCase().endsWith('.json')) {
                showToast('Please select a JSON file', 'error');
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const result = importDashboardData(e.target.result);
                    
                    if (result.success) {
                        showToast('Dashboard imported successfully', 'success');
                        announceChange('Dashboard configuration imported');
                    } else {
                        showToast(`Import failed: ${result.errors.join(', ')}`, 'error');
                    }
                    
                } catch (error) {
                    console.error('Error reading file:', error);
                    showToast('Error reading file', 'error');
                }
            };
            
            reader.onerror = function() {
                showToast('Error reading file', 'error');
            };
            
            reader.readAsText(file);
        }
        
        /**
         * Restore chart settings from imported data
         * @param {Object} chartSettings - Chart settings object
         */
        function restoreChartSettings(chartSettings) {
            try {
                Object.entries(chartSettings).forEach(([key, value]) => {
                    const element = document.getElementById(key);
                    if (element) {
                        if (element.type === 'checkbox') {
                            element.checked = value;
                        } else {
                            element.value = value;
                        }
                    }
                });
                
                // Update dependent UI elements
                toggleDataLabelOptions();
                toggleManualOpacityControls();
                
            } catch (error) {
                console.error('Error restoring chart settings:', error);
            }
        }
        
        // ===== UTILITY FUNCTIONS =====
        
        /**
         * Generate unique ID for new items
         * @param {string} baseName - Base name to generate ID from
         * @param {Array} collection - Existing collection to check against
         * @returns {string} Unique ID
         */
        function generateUniqueId(baseName, collection) {
            let baseId = baseName.toLowerCase()
                .replace(/\s+/g, '_')
                .replace(/[^a-z0-9_]/g, '');
            
            // If base ID is empty, use a generic prefix
            if (!baseId) {
                baseId = 'item';
            }
            
            // Check if ID already exists
            let counter = 1;
            let finalId = baseId;
            
            while (collection.some(item => item.id === finalId)) {
                finalId = baseId + '_' + counter;
                counter++;
            }
            
            return finalId;
        }
        
        /**
         * Deep clone an object
         * @param {*} obj - Object to clone
         * @returns {*} Deep cloned object
         */
        function deepClone(obj) {
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }
            
            if (obj instanceof Date) {
                return new Date(obj.getTime());
            }
            
            if (obj instanceof Array) {
                return obj.map(item => deepClone(item));
            }
            
            if (typeof obj === 'object') {
                const cloned = {};
                Object.keys(obj).forEach(key => {
                    cloned[key] = deepClone(obj[key]);
                });
                return cloned;
            }
            
            return obj;
        }
        
        /**
         * Merge objects recursively
         * @param {Object} target - Target object
         * @param {Object} source - Source object
         * @returns {Object} Merged object
         */
        function mergeDeep(target, source) {
            const result = { ...target };
            
            Object.keys(source).forEach(key => {
                if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                    result[key] = mergeDeep(result[key] || {}, source[key]);
                } else {
                    result[key] = source[key];
                }
            });
            
            return result;
        }
        
        /**
         * Format numbers with proper locale formatting
         * @param {number} num - Number to format
         * @param {Object} options - Formatting options
         * @returns {string} Formatted number
         */
        function formatNumber(num, options = {}) {
            const defaults = {
                minimumFractionDigits: 0,
                maximumFractionDigits: 2
            };
            
            const settings = { ...defaults, ...options };
            
            try {
                return new Intl.NumberFormat('en-US', settings).format(num);
            } catch (error) {
                // Fallback for older browsers
                return num.toFixed(settings.maximumFractionDigits);
            }
        }
        
        /**
         * Format dates with proper locale formatting
         * @param {Date} date - Date to format
         * @param {Object} options - Formatting options
         * @returns {string} Formatted date
         */
        function formatDate(date, options = {}) {
            const defaults = {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            };
            
            const settings = { ...defaults, ...options };
            
            try {
                return new Intl.DateTimeFormat('en-US', settings).format(date);
            } catch (error) {
                // Fallback for older browsers
                return date.toLocaleDateString();
            }
        }
        
        /**
         * Calculate statistics for a dataset
         * @param {Array} data - Array of numbers
         * @returns {Object} Statistics object
         */
        function calculateStatistics(data) {
            if (!Array.isArray(data) || data.length === 0) {
                return { mean: 0, median: 0, min: 0, max: 0, sum: 0, count: 0 };
            }
            
            const numbers = data.filter(n => typeof n === 'number' && !isNaN(n));
            if (numbers.length === 0) {
                return { mean: 0, median: 0, min: 0, max: 0, sum: 0, count: 0 };
            }
            
            const sorted = [...numbers].sort((a, b) => a - b);
            const sum = numbers.reduce((acc, val) => acc + val, 0);
            const mean = sum / numbers.length;
            
            const median = numbers.length % 2 === 0
                ? (sorted[numbers.length / 2 - 1] + sorted[numbers.length / 2]) / 2
                : sorted[Math.floor(numbers.length / 2)];
            
            return {
                mean: mean,
                median: median,
                min: Math.min(...numbers),
                max: Math.max(...numbers),
                sum: sum,
                count: numbers.length
            };
        }
        
        /**
         * Generate a random color in hex format
         * @returns {string} Random hex color
         */
        function generateRandomColor() {
            const hue = Math.floor(Math.random() * 360);
            const saturation = 70 + Math.floor(Math.random() * 30); // 70-100%
            const lightness = 45 + Math.floor(Math.random() * 20);  // 45-65%
            
            return hslToHex(hue, saturation, lightness);
        }
        
        /**
         * Convert HSL to Hex color
         * @param {number} h - Hue (0-360)
         * @param {number} s - Saturation (0-100)
         * @param {number} l - Lightness (0-100)
         * @returns {string} Hex color
         */
        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            
            return `#${f(0)}${f(8)}${f(4)}`;
        }
        
        /**
         * Check if a color is light or dark
         * @param {string} hex - Hex color
         * @returns {string} 'light' or 'dark'
         */
        function getColorBrightness(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return 'dark';
            
            // Calculate relative luminance
            const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
            
            return luminance > 0.5 ? 'light' : 'dark';
        }
        
        /**
         * Sanitize string for use as filename
         * @param {string} str - String to sanitize
         * @returns {string} Sanitized string
         */
        function sanitizeFilename(str) {
            return str
                .replace(/[^a-z0-9]/gi, '_')
                .replace(/_{2,}/g, '_')
                .replace(/^_|_$/g, '')
                .toLowerCase();
        }
        
        /**
         * Generate timestamp string for filenames
         * @returns {string} Timestamp string
         */
        function getTimestamp() {
            return new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
        }
        
        /**
         * Check if browser supports a specific feature
         * @param {string} feature - Feature name
         * @returns {boolean} Support status
         */
        function supportsFeature(feature) {
            const features = {
                localStorage: typeof Storage !== 'undefined',
                canvas: !!document.createElement('canvas').getContext,
                flexbox: CSS.supports('display', 'flex'),
                grid: CSS.supports('display', 'grid'),
                es6: typeof Symbol !== 'undefined',
                fetch: typeof fetch !== 'undefined',
                intersectionObserver: 'IntersectionObserver' in window,
                customElements: 'customElements' in window,
                webgl: (() => {
                    try {
                        const canvas = document.createElement('canvas');
                        return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
                    } catch (e) {
                        return false;
                    }
                })()
            };
            
            return features[feature] || false;
        }
        
        // ===== FILE MANAGEMENT UTILITIES =====
        
        /**
         * Create and trigger download of a file
         * @param {string} content - File content
         * @param {string} filename - Filename
         * @param {string} mimeType - MIME type
         */
        function downloadFile(content, filename, mimeType = 'text/plain') {
            try {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error downloading file:', error);
                showToast('Failed to download file', 'error');
            }
        }
        
        /**
         * Read file content as text
         * @param {File} file - File object
         * @returns {Promise<string>} File content
         */
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    resolve(e.target.result);
                };
                
                reader.onerror = function() {
                    reject(new Error('Failed to read file'));
                };
                
                reader.readAsText(file);
            });
        }
        
        /**
         * Validate file type and size
         * @param {File} file - File object
         * @param {Array} allowedTypes - Allowed MIME types
         * @param {number} maxSize - Maximum file size in bytes
         * @returns {Object} Validation result
         */
        function validateFile(file, allowedTypes = [], maxSize = 10 * 1024 * 1024) {
            const errors = [];
            
            if (!file) {
                errors.push('No file selected');
                return { valid: false, errors };
            }
            
            if (allowedTypes.length > 0 && !allowedTypes.includes(file.type)) {
                errors.push(`Invalid file type. Allowed: ${allowedTypes.join(', ')}`);
            }
            
            if (file.size > maxSize) {
                errors.push(`File too large. Maximum size: ${formatFileSize(maxSize)}`);
            }
            
            return {
                valid: errors.length === 0,
                errors: errors
            };
        }
        
        /**
         * Format file size in human readable format
         * @param {number} bytes - File size in bytes
         * @returns {string} Formatted file size
         */
        function formatFileSize(bytes) {
            const units = ['B', 'KB', 'MB', 'GB'];
            let size = bytes;
            let unitIndex = 0;
            
            while (size >= 1024 && unitIndex < units.length - 1) {
                size /= 1024;
                unitIndex++;
            }
            
            return `${size.toFixed(1)} ${units[unitIndex]}`;
        }
        
        // ===== TEMPLATE MANAGEMENT =====
        
        /**
         * Create a dashboard template
         * @param {string} name - Template name
         * @param {string} description - Template description
         * @returns {Object} Template object
         */
        function createTemplate(name, description = '') {
            return {
                id: generateUniqueId(name, []),
                name: name,
                description: description,
                created: new Date().toISOString(),
                version: '2.0',
                data: exportDashboardData()
            };
        }
        
        /**
         * Load a dashboard template
         * @param {Object} template - Template object
         * @returns {boolean} Success status
         */
        function loadTemplate(template) {
            if (!template || !template.data) {
                showToast('Invalid template', 'error');
                return false;
            }
            
            try {
                const result = importDashboardData(template.data);
                
                if (result.success) {
                    showToast(`Template "${template.name}" loaded successfully`, 'success');
                    announceChange(`Loaded template: ${template.name}`);
                    return true;
                } else {
                    showToast(`Failed to load template: ${result.errors.join(', ')}`, 'error');
                    return false;
                }
                
            } catch (error) {
                console.error('Error loading template:', error);
                showToast('Error loading template', 'error');
                return false;
            }
        }
        
        // ===== BACKUP & RECOVERY =====
        
        /**
         * Create automatic backup of current state
         */
        function createAutoBackup() {
            try {
                const backupData = {
                    timestamp: new Date().toISOString(),
                    data: exportDashboardData(),
                    version: '2.0'
                };
                
                // Store in sessionStorage for temporary backup
                if (supportsFeature('localStorage')) {
                    const backupKey = `dashboard_backup_${getTimestamp()}`;
                    sessionStorage.setItem(backupKey, JSON.stringify(backupData));
                    
                    // Keep only last 5 backups
                    const allKeys = Object.keys(sessionStorage).filter(key => key.startsWith('dashboard_backup_'));
                    if (allKeys.length > 5) {
                        allKeys.sort().slice(0, allKeys.length - 5).forEach(key => {
                            sessionStorage.removeItem(key);
                        });
                    }
                }
                
                console.log('Auto backup created');
                
            } catch (error) {
                console.error('Error creating auto backup:', error);
            }
        }
        
        /**
         * Restore from the most recent backup
         * @returns {boolean} Success status
         */
        function restoreFromBackup() {
            try {
                if (!supportsFeature('localStorage')) {
                    showToast('Backup feature not supported in this browser', 'error');
                    return false;
                }
                
                const backupKeys = Object.keys(sessionStorage)
                    .filter(key => key.startsWith('dashboard_backup_'))
                    .sort()
                    .reverse();
                
                if (backupKeys.length === 0) {
                    showToast('No backups available', 'warning');
                    return false;
                }
                
                const latestBackupKey = backupKeys[0];
                const backupData = JSON.parse(sessionStorage.getItem(latestBackupKey));
                
                const result = importDashboardData(backupData.data);
                
                if (result.success) {
                    showToast('Restored from backup successfully', 'success');
                    announceChange('Dashboard restored from backup');
                    return true;
                } else {
                    showToast(`Failed to restore backup: ${result.errors.join(', ')}`, 'error');
                    return false;
                }
                
            } catch (error) {
                console.error('Error restoring from backup:', error);
                showToast('Error restoring from backup', 'error');
                return false;
            }
        }
        
        /**
         * Get list of available backups
         * @returns {Array} Array of backup objects
         */
        function getAvailableBackups() {
            try {
                if (!supportsFeature('localStorage')) {
                    return [];
                }
                
                const backupKeys = Object.keys(sessionStorage)
                    .filter(key => key.startsWith('dashboard_backup_'))
                    .sort()
                    .reverse();
                
                return backupKeys.map(key => {
                    try {
                        const backup = JSON.parse(sessionStorage.getItem(key));
                        return {
                            key: key,
                            timestamp: backup.timestamp,
                            date: new Date(backup.timestamp),
                            version: backup.version
                        };
                    } catch (error) {
                        return null;
                    }
                }).filter(backup => backup !== null);
                
            } catch (error) {
                console.error('Error getting available backups:', error);
                return [];
            }
        }
        
        // ===== VALIDATION UTILITIES =====
        
        /**
         * Validate imported data structure
         * @param {Object} data - Data to validate
         * @returns {Object} Validation result
         */
        function validateImportedData(data) {
            const errors = [];
            
            // Check required fields
            if (!data.configuration) {
                errors.push('Missing configuration object');
                return { valid: false, errors };
            }
            
            const config = data.configuration;
            
            // Validate arrays
            if (!Array.isArray(config.years) || config.years.length === 0) {
                errors.push('Invalid or empty years array');
            }
            
            if (!Array.isArray(config.categories) || config.categories.length === 0) {
                errors.push('Invalid or empty categories array');
            }
            
            if (!Array.isArray(config.functions) || config.functions.length === 0) {
                errors.push('Invalid or empty functions array');
            }
            
            // Validate data structure integrity
            if (config.functionData && typeof config.functionData === 'object') {
                for (const funcId in config.functionData) {
                    if (!config.functions.some(f => f.id === funcId)) {
                        errors.push(`Data exists for unknown function: ${funcId}`);
                    }
                }
            }
            
            // Validate version compatibility
            if (data.version && parseFloat(data.version) > 2.0) {
                errors.push('Data version is newer than supported version');
            }
            
            return {
                valid: errors.length === 0,
                errors: errors
            };
        }
        
        /**
         * Validate color format
         * @param {string} color - Color string to validate
         * @returns {boolean} Validation result
         */
        function validateColor(color) {
            if (typeof color !== 'string') return false;
            
            // Check hex color format
            const hexPattern = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
            if (hexPattern.test(color)) return true;
            
            // Check named colors (basic validation)
            const namedColors = ['red', 'green', 'blue', 'yellow', 'orange', 'purple', 'pink', 'brown', 'black', 'white'];
            if (namedColors.includes(color.toLowerCase())) return true;
            
            // Check rgb/rgba format
            const rgbPattern = /^rgb\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/;
            const rgbaPattern = /^rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*[\d.]+\s*\)$/;
            
            return rgbPattern.test(color) || rgbaPattern.test(color);
        }
        
        /**
         * Sanitize and validate user input
         * @param {string} input - User input to sanitize
         * @param {Object} options - Sanitization options
         * @returns {string} Sanitized input
         */
        function sanitizeInput(input, options = {}) {
            if (typeof input !== 'string') return '';
            
            const defaults = {
                maxLength: 100,
                allowNumbers: true,
                allowLetters: true,
                allowSpaces: true,
                allowSpecialChars: false
            };
            
            const settings = { ...defaults, ...options };
            
            let sanitized = input.trim();
            
            // Limit length
            if (sanitized.length > settings.maxLength) {
                sanitized = sanitized.substring(0, settings.maxLength);
            }
            
            // Build allowed character pattern
            let pattern = '';
            if (settings.allowLetters) pattern += 'a-zA-Z';
            if (settings.allowNumbers) pattern += '0-9';
            if (settings.allowSpaces) pattern += '\\s';
            if (settings.allowSpecialChars) pattern += '\\-_\\.';
            
            if (pattern) {
                const regex = new RegExp(`[^${pattern}]`, 'g');
                sanitized = sanitized.replace(regex, '');
            }
            
            return sanitized;
        }
        
        // ===== PERFORMANCE UTILITIES =====
        
        /**
         * Measure function execution time
         * @param {Function} fn - Function to measure
         * @param {...any} args - Function arguments
         * @returns {Object} Result and timing information
         */
        function measurePerformance(fn, ...args) {
            const startTime = performance.now();
            const result = fn(...args);
            const endTime = performance.now();
            
            return {
                result: result,
                executionTime: endTime - startTime,
                startTime: startTime,
                endTime: endTime
            };
        }
        
        /**
         * Debounce function execution
         * @param {Function} func - Function to debounce
         * @param {number} delay - Delay in milliseconds
         * @returns {Function} Debounced function
         */
        function createDebounce(func, delay) {
            let timeoutId;
            
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(this, args), delay);
            };
        }
        
        /**
         * Throttle function execution
         * @param {Function} func - Function to throttle
         * @param {number} limit - Time limit in milliseconds
         * @returns {Function} Throttled function
         */
        function createThrottle(func, limit) {
            let inThrottle;
            
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }
        
        /**
         * Cache function results
         * @param {Function} func - Function to cache
         * @param {number} maxSize - Maximum cache size
         * @returns {Function} Cached function
         */
        function createCache(func, maxSize = 100) {
            const cache = new Map();
            
            return function(...args) {
                const key = JSON.stringify(args);
                
                if (cache.has(key)) {
                    return cache.get(key);
                }
                
                const result = func.apply(this, args);
                
                if (cache.size >= maxSize) {
                    const firstKey = cache.keys().next().value;
                    cache.delete(firstKey);
                }
                
                cache.set(key, result);
                return result;
            };
        }
        
        // ===== EXPORT MENU CREATION =====
        
        /**
         * Create export menu UI
         * @returns {HTMLElement} Export menu element
         */
        function createExportMenu() {
            const menu = document.createElement('div');
            menu.className = 'export-menu';
            menu.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border: 2px solid #667eea;
                border-radius: 12px;
                padding: 25px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
                z-index: 10000;
                min-width: 350px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            `;
            
            menu.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0; color: #333;">Export Dashboard</h3>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;"
                            aria-label="Close export menu"></button>
                </div>
                
                <div style="display: grid; gap: 15px;">
                    <button onclick="downloadDashboardData(); this.parentElement.parentElement.remove();" 
                            style="padding: 12px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                         Export Complete Dashboard (JSON)
                    </button>
                    
                    <button onclick="downloadChartDataAsCSV(); this.parentElement.parentElement.remove();" 
                            style="padding: 12px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                         Export Chart Data (CSV)
                    </button>
                    
                    <button onclick="downloadSummaryReport(); this.parentElement.parentElement.remove();" 
                            style="padding: 12px; background: #ff9800; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                         Export Summary Report (TXT)
                    </button>
                    
                    <button onclick="exportChartImage(); this.parentElement.parentElement.remove();" 
                            style="padding: 12px; background: #9c27b0; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                         Export Chart Image (PNG)
                    </button>
                </div>
                
                <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; font-size: 12px; color: #666;">
                    <strong>Export Options:</strong><br>
                     Complete Dashboard: Full configuration and data<br>
                     Chart Data: Raw data in spreadsheet format<br>
                     Summary Report: Analysis and insights<br>
                     Chart Image: Visual snapshot for presentations
                </div>
            `;
            
            // Add overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
            `;
            overlay.onclick = function() {
                document.body.removeChild(overlay);
                document.body.removeChild(menu);
            };
            
            document.body.appendChild(overlay);
            document.body.appendChild(menu);
            
            return menu;
        }
        
        /**
         * Create import menu UI
         * @returns {HTMLElement} Import menu element
         */
        function createImportMenu() {
            const menu = document.createElement('div');
            menu.className = 'import-menu';
            menu.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border: 2px solid #667eea;
                border-radius: 12px;
                padding: 25px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
                z-index: 10000;
                min-width: 350px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            `;
            
            menu.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0; color: #333;">Import Dashboard</h3>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;"
                            aria-label="Close import menu"></button>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label for="importFile" style="display: block; margin-bottom: 10px; font-weight: 500; color: #555;">
                        Select Dashboard File (JSON):
                    </label>
                    <input type="file" id="importFile" accept=".json" 
                           style="width: 100%; padding: 10px; border: 2px dashed #667eea; border-radius: 6px; background: #f8f9ff;">
                </div>
                
                <div style="display: grid; gap: 10px;">
                    <button onclick="handleImportFile()" 
                            style="padding: 12px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                         Import Dashboard
                    </button>
                    
                    <button onclick="restoreFromBackup(); this.parentElement.parentElement.remove();" 
                            style="padding: 12px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                         Restore from Backup
                    </button>
                </div>
                
                <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; font-size: 12px; color: #666;">
                    <strong> Important:</strong><br>
                    Importing will replace your current dashboard configuration. 
                    An automatic backup will be created before importing.
                </div>
            `;
            
            // Add overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
            `;
            overlay.onclick = function() {
                document.body.removeChild(overlay);
                document.body.removeChild(menu);
            };
            
            document.body.appendChild(overlay);
            document.body.appendChild(menu);
            
            return menu;
        }
        
        /**
         * Handle import file selection
         */
        function handleImportFile() {
            const fileInput = document.getElementById('importFile');
            const file = fileInput?.files[0];
            
            if (!file) {
                showToast('Please select a file to import', 'warning');
                return;
            }
            
            // Create backup before importing
            createAutoBackup();
            
            // Import the file
            importFromFile(file);
            
            // Close the menu
            const menu = document.querySelector('.import-menu');
            const overlay = document.querySelector('div[style*="rgba(0,0,0,0.5)"]');
            if (menu) menu.remove();
            if (overlay) overlay.remove();
        }
        
        // ===== GLOBAL UTILITY FUNCTIONS =====
        
        /**
         * Show export menu
         */
        function showExportMenu() {
            createExportMenu();
        }
        
        /**
         * Show import menu
         */
        function showImportMenu() {
            createImportMenu();
        }
        
        /**
         * Reset dashboard to factory defaults with confirmation
         */
        function resetDashboardWithConfirmation() {
            if (confirm('Are you sure you want to reset the dashboard to default settings? This action cannot be undone.')) {
                // Create backup before reset
                createAutoBackup();
                
                // Reset to defaults
                resetToDefaults();
                
                // Re-render everything
                renderAllComponents();
                createCharts();
                
                showToast('Dashboard reset to default settings', 'success');
                announceChange('Dashboard reset to default configuration');
            }
        }
        
        // ===== AUTOMATIC BACKUP SCHEDULER =====
        
        /**
         * Start automatic backup scheduler
         */
        function startAutoBackupScheduler() {
            // Create backup every 5 minutes if there are changes
            setInterval(() => {
                if (document.body.dataset.hasChanges === 'true') {
                    createAutoBackup();
                    document.body.dataset.hasChanges = 'false';
                }
            }, 5 * 60 * 1000); // 5 minutes
        }
        
        /**
         * Mark dashboard as having changes
         */
        function markAsChanged() {
            document.body.dataset.hasChanges = 'true';
        }
        
        // ===== INITIALIZATION =====
        
        // Start auto backup scheduler when dashboard is ready
        document.addEventListener('dashboardReady', function() {
            startAutoBackupScheduler();
            console.log('Auto backup scheduler started');
        });
        
        // Mark as changed when data is modified
        const originalSetDataValue = setDataValue;
        window.setDataValue = function(...args) {
            const result = originalSetDataValue.apply(this, args);
            if (result) markAsChanged();
            return result;
        };
        
        /* ===========================================
           END OF PART 7: EXPORT/IMPORT & UTILITY FUNCTIONS
           =========================================== */
        /* ===========================================
           PART 8: FINAL INTEGRATION & SETUP
           =========================================== */
        
        // ===== FINAL DASHBOARD INITIALIZATION =====
        
        /**
         * Complete dashboard setup and integration
         * This is the final initialization that ties everything together
         */
        function completeDashboardSetup() {
            console.log('Starting complete dashboard setup...');
            
            try {
                // Phase 1: Verify all components are loaded
                verifyComponentsLoaded();
                
                // Phase 2: Setup menu integrations
                setupMenuIntegrations();
                
                // Phase 3: Initialize keyboard shortcuts
                initializeKeyboardShortcuts();
                
                // Phase 4: Setup context menus
                setupContextMenus();
                
                // Phase 5: Initialize help system
                initializeHelpSystem();
                
                // Phase 6: Setup auto-save functionality
                setupAutoSave();
                
                // Phase 7: Initialize tour system
                initializeTourSystem();
                
                // Phase 8: Final validations and cleanup
                performFinalValidations();
                
                // Mark dashboard as fully ready
                markDashboardReady();
                
                console.log('Complete dashboard setup finished successfully');
                
            } catch (error) {
                console.error('Error in complete dashboard setup:', error);
                handleSetupError(error);
            }
        }
        
        /**
         * Verify all required components are loaded and functional
         */
        function verifyComponentsLoaded() {
            const requiredFunctions = [
                'createCharts', 'renderAllComponents', 'initializeEventListeners',
                'exportDashboardData', 'importDashboardData', 'validateDataIntegrity'
            ];
            
            const missingFunctions = requiredFunctions.filter(fn => typeof window[fn] !== 'function');
            
            if (missingFunctions.length > 0) {
                throw new Error(`Missing required functions: ${missingFunctions.join(', ')}`);
            }
            
            // Verify Chart.js is loaded
            if (typeof Chart === 'undefined') {
                throw new Error('Chart.js library not loaded');
            }
            
            // Verify data structures exist
            if (!Array.isArray(functions) || !Array.isArray(categories) || !Array.isArray(years)) {
                throw new Error('Core data structures not properly initialized');
            }
            
            console.log('All components verified successfully');
        }
        
        // ===== MENU INTEGRATIONS =====
        
        /**
         * Setup main menu integrations and toolbar
         */
        function setupMenuIntegrations() {
            console.log('Setting up menu integrations...');
            
            // Add main toolbar if it doesn't exist
            createMainToolbar();
            
            // Setup export/import menu integration
            integrateExportImportMenus();
            
            // Setup chart controls integration
            integrateChartControls();
            
            // Setup help menu integration
            integrateHelpMenu();
        }
        
        /**
         * Create main toolbar with all dashboard actions
         */
        function createMainToolbar() {
            // Check if toolbar already exists
            if (document.getElementById('main-toolbar')) return;
            
            const toolbar = document.createElement('div');
            toolbar.id = 'main-toolbar';
            toolbar.className = 'main-toolbar fade-in';
            toolbar.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                display: flex;
                gap: 10px;
                z-index: 1000;
                background: rgba(255, 255, 255, 0.95);
                padding: 10px;
                border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.1);
                backdrop-filter: blur(5px);
            `;
            
            toolbar.innerHTML = `
                <button onclick="showExportMenu()" 
                        title="Export Dashboard" 
                        aria-label="Export dashboard data"
                        style="background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px;">
                     Export
                </button>
                
                <button onclick="showImportMenu()" 
                        title="Import Dashboard" 
                        aria-label="Import dashboard data"
                        style="background: #4CAF50; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px;">
                     Import
                </button>
                
                <button onclick="showHelpDialog()" 
                        title="Show Help" 
                        aria-label="Show help and keyboard shortcuts"
                        style="background: #ff9800; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px;">
                     Help
                </button>
                
                <button onclick="toggleDashboardTour()" 
                        title="Dashboard Tour" 
                        aria-label="Start guided tour"
                        style="background: #9c27b0; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px;">
                     Tour
                </button>
                
                <button onclick="resetDashboardWithConfirmation()" 
                        title="Reset Dashboard" 
                        aria-label="Reset to default settings"
                        style="background: #f44336; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px;">
                     Reset
                </button>
            `;
            
            document.body.appendChild(toolbar);
        }
        
        /**
         * Integrate export/import menus with main interface
         */
        function integrateExportImportMenus() {
            // Add export/import buttons to main controls if not present
            const controls = document.querySelector('.controls');
            if (controls && !document.getElementById('integrated-export-btn')) {
                const exportGroup = document.createElement('div');
                exportGroup.className = 'control-group';
                exportGroup.innerHTML = `
                    <label>Data Management</label>
                    <button id="integrated-export-btn" onclick="showExportMenu()" aria-label="Export dashboard data">
                        Export Data
                    </button>
                `;
                controls.appendChild(exportGroup);
                
                const importGroup = document.createElement('div');
                importGroup.className = 'control-group';
                importGroup.innerHTML = `
                    <label>&nbsp;</label>
                    <button id="integrated-import-btn" onclick="showImportMenu()" aria-label="Import dashboard data">
                        Import Data
                    </button>
                `;
                controls.appendChild(importGroup);
            }
        }
        
        /**
         * Integrate chart controls with main interface
         */
        function integrateChartControls() {
            // Add advanced chart controls
            const chartContainer = document.getElementById('chartContainer');
            if (chartContainer && !document.getElementById('chart-tools')) {
                const tools = document.createElement('div');
                tools.id = 'chart-tools';
                tools.style.cssText = `
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    display: flex;
                    gap: 5px;
                    z-index: 100;
                `;
                
                tools.innerHTML = `
                    <button onclick="exportChartImage()" 
                            title="Export Chart as Image"
                            style="background: rgba(102, 126, 234, 0.9); color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        
                    </button>
                    
                    <button onclick="toggleChartMaximize()" 
                            title="Maximize Chart"
                            style="background: rgba(102, 126, 234, 0.9); color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        
                    </button>
                `;
                
                chartContainer.style.position = 'relative';
                chartContainer.appendChild(tools);
            }
        }
        
        /**
         * Integrate help menu with main interface
         */
        function integrateHelpMenu() {
            // Add help icon to header if not present
            const header = document.querySelector('.header');
            if (header && !document.getElementById('header-help')) {
                const helpIcon = document.createElement('button');
                helpIcon.id = 'header-help';
                helpIcon.onclick = showHelpDialog;
                helpIcon.setAttribute('aria-label', 'Show help');
                helpIcon.style.cssText = `
                    position: absolute;
                    top: 15px;
                    right: 15px;
                    background: rgba(255, 255, 255, 0.2);
                    color: white;
                    border: none;
                    width: 40px;
                    height: 40px;
                    border-radius: 50%;
                    cursor: pointer;
                    font-size: 18px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.3s ease;
                `;
                helpIcon.innerHTML = '?';
                helpIcon.onmouseover = () => helpIcon.style.background = 'rgba(255, 255, 255, 0.3)';
                helpIcon.onmouseout = () => helpIcon.style.background = 'rgba(255, 255, 255, 0.2)';
                
                header.appendChild(helpIcon);
            }
        }
        
        // ===== KEYBOARD SHORTCUTS =====
        
        /**
         * Initialize comprehensive keyboard shortcuts
         */
        function initializeKeyboardShortcuts() {
            console.log('Initializing keyboard shortcuts...');
            
            document.addEventListener('keydown', function(event) {
                // Only handle shortcuts when not typing in inputs
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                const { ctrlKey, altKey, shiftKey, key } = event;
                
                // Ctrl+Shift combinations
                if (ctrlKey && shiftKey) {
                    switch (key) {
                        case 'E':
                            event.preventDefault();
                            showExportMenu();
                            announceChange('Export menu opened');
                            break;
                        case 'I':
                            event.preventDefault();
                            showImportMenu();
                            announceChange('Import menu opened');
                            break;
                        case 'R':
                            event.preventDefault();
                            resetDashboardWithConfirmation();
                            break;
                        case 'H':
                            event.preventDefault();
                            showHelpDialog();
                            break;
                        case 'T':
                            event.preventDefault();
                            toggleDashboardTour();
                            break;
                    }
                }
                // Ctrl combinations
                else if (ctrlKey && !altKey) {
                    switch (key) {
                        case 'e':
                            event.preventDefault();
                            exportChartImage();
                            break;
                        case 'm':
                            event.preventDefault();
                            toggleChartMaximize();
                            break;
                        case 's':
                            event.preventDefault();
                            triggerAutoSave();
                            announceChange('Dashboard saved');
                            break;
                        case 'z':
                            event.preventDefault();
                            restoreFromBackup();
                            break;
                    }
                }
                // Alt combinations
                else if (altKey && !ctrlKey) {
                    switch (key) {
                        case '1':
                            event.preventDefault();
                            switchToChartType('bar');
                            break;
                        case '2':
                            event.preventDefault();
                            switchToChartType('horizontalBar');
                            break;
                        case 'a':
                            event.preventDefault();
                            toggleAnimation();
                            break;
                        case 't':
                            event.preventDefault();
                            toggleTrendLines();
                            break;
                        case 'd':
                            event.preventDefault();
                            toggleDataLabels();
                            break;
                    }
                }
                // Function keys
                else if (!ctrlKey && !altKey) {
                    switch (key) {
                        case 'F1':
                            event.preventDefault();
                            showHelpDialog();
                            break;
                        case 'F2':
                            event.preventDefault();
                            focusFirstEditableElement();
                            break;
                        case 'F5':
                            event.preventDefault();
                            createCharts();
                            announceChange('Charts refreshed');
                            break;
                        case 'Escape':
                            event.preventDefault();
                            closeAllModals();
                            break;
                    }
                }
            });
            
            // Show keyboard shortcuts hint
            showToast('Press F1 for keyboard shortcuts', 'info', 2000);
        }
        
        /**
         * Helper functions for keyboard shortcuts
         */
        function switchToChartType(type) {
            const chartTypeSelect = document.getElementById('chartType');
            if (chartTypeSelect) {
                chartTypeSelect.value = type;
                createCharts();
                announceChange(`Switched to ${type} chart`);
            }
        }
        
        function toggleAnimation() {
            const animationSelect = document.getElementById('animation');
            if (animationSelect) {
                animationSelect.value = animationSelect.value === 'true' ? 'false' : 'true';
                createCharts();
                announceChange(`Animation ${animationSelect.value === 'true' ? 'enabled' : 'disabled'}`);
            }
        }
        
        function toggleTrendLines() {
            const trendLineCheck = document.getElementById('showTrendLine');
            if (trendLineCheck) {
                trendLineCheck.checked = !trendLineCheck.checked;
                createCharts();
                announceChange(`Trend lines ${trendLineCheck.checked ? 'enabled' : 'disabled'}`);
            }
        }
        
        function toggleDataLabels() {
            const dataLabelsCheck = document.getElementById('showDataLabels');
            if (dataLabelsCheck) {
                dataLabelsCheck.checked = !dataLabelsCheck.checked;
                toggleDataLabelOptions();
                createCharts();
                announceChange(`Data labels ${dataLabelsCheck.checked ? 'enabled' : 'disabled'}`);
            }
        }
        
        function focusFirstEditableElement() {
            const firstInput = document.querySelector('input:not([type="file"]):not([type="checkbox"]):not([type="radio"]), select');
            if (firstInput) {
                firstInput.focus();
                announceChange('Focused on first input field');
            }
        }
        
        function closeAllModals() {
            // Close export/import menus
            document.querySelectorAll('.export-menu, .import-menu, .help-dialog, .tour-overlay').forEach(el => {
                el.remove();
            });
            
            // Close maximized chart
            if (isChartMaximized) {
                toggleChartMaximize();
            }
            
            // Cancel any edit modes
            cancelAllEditModes();
            renderAllComponents();
            
            announceChange('All dialogs closed');
        }
        
        // ===== CONTEXT MENUS =====
        
        /**
         * Setup context menus for right-click interactions
         */
        function setupContextMenus() {
            console.log('Setting up context menus...');
            
            // Chart context menu
            setupChartContextMenu();
            
            // Function context menu
            setupFunctionContextMenu();
            
            // Category context menu
            setupCategoryContextMenu();
        }
        
        /**
         * Setup context menu for chart area
         */
        function setupChartContextMenu() {
            const chartCanvas = document.getElementById('qaChart');
            if (!chartCanvas) return;
            
            chartCanvas.addEventListener('contextmenu', function(event) {
                event.preventDefault();
                
                const contextMenu = createContextMenu([
                    { label: 'Export as Image', action: () => exportChartImage() },
                    { label: 'Maximize Chart', action: () => toggleChartMaximize() },
                    { label: 'Refresh Chart', action: () => createCharts() },
                    { separator: true },
                    { label: 'Export Data as CSV', action: () => downloadChartDataAsCSV() },
                    { label: 'Show Summary Report', action: () => downloadSummaryReport() }
                ]);
                
                positionContextMenu(contextMenu, event.clientX, event.clientY);
            });
        }
        
        /**
         * Setup context menu for function items
         */
        function setupFunctionContextMenu() {
            document.addEventListener('contextmenu', function(event) {
                if (event.target.closest('.sort-item')) {
                    event.preventDefault();
                    
                    const functionItem = event.target.closest('.sort-item');
                    const functionIndex = Array.from(functionItem.parentElement.children).indexOf(functionItem);
                    
                    const contextMenu = createContextMenu([
                        { label: 'Rename Function', action: () => startEditFunction(functionIndex) },
                        { label: 'Move Up', action: () => moveFunctionUp(functionIndex), disabled: functionIndex === 0 },
                        { label: 'Move Down', action: () => moveFunctionDown(functionIndex), disabled: functionIndex === functions.length - 1 },
                        { separator: true },
                        { label: 'Remove Function', action: () => removeFunction(functionIndex), disabled: functions.length <= 1 }
                    ]);
                    
                    positionContextMenu(contextMenu, event.clientX, event.clientY);
                }
            });
        }
        
        /**
         * Setup context menu for category items
         */
        function setupCategoryContextMenu() {
            document.addEventListener('contextmenu', function(event) {
                if (event.target.closest('.item')) {
                    event.preventDefault();
                    
                    const categoryItem = event.target.closest('.item');
                    const categoryIndex = Array.from(categoryItem.parentElement.children).indexOf(categoryItem);
                    
                    const contextMenu = createContextMenu([
                        { label: 'Rename Category', action: () => startEditCategory(categoryIndex) },
                        { label: 'Change Color', action: () => focusCategoryColor(categoryIndex) },
                        { separator: true },
                        { label: 'Remove Category', action: () => removeCategory(categoryIndex), disabled: categories.length <= 1 }
                    ]);
                    
                    positionContextMenu(contextMenu, event.clientX, event.clientY);
                }
            });
        }
        
        /**
         * Create a context menu element
         * @param {Array} items - Menu items
         * @returns {HTMLElement} Context menu element
         */
        function createContextMenu(items) {
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.cssText = `
                position: fixed;
                background: white;
                border: 1px solid #ccc;
                border-radius: 6px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.15);
                z-index: 10000;
                min-width: 150px;
                padding: 5px 0;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 14px;
            `;
            
            items.forEach(item => {
                if (item.separator) {
                    const separator = document.createElement('div');
                    separator.style.cssText = `
                        height: 1px;
                        background: #eee;
                        margin: 5px 0;
                    `;
                    menu.appendChild(separator);
                } else {
                    const menuItem = document.createElement('div');
                    menuItem.textContent = item.label;
                    menuItem.style.cssText = `
                        padding: 8px 16px;
                        cursor: ${item.disabled ? 'not-allowed' : 'pointer'};
                        color: ${item.disabled ? '#999' : '#333'};
                        transition: background-color 0.2s ease;
                    `;
                    
                    if (!item.disabled) {
                        menuItem.onmouseover = () => menuItem.style.backgroundColor = '#f0f0f0';
                        menuItem.onmouseout = () => menuItem.style.backgroundColor = 'transparent';
                        menuItem.onclick = () => {
                            item.action();
                            menu.remove();
                        };
                    }
                    
                    menu.appendChild(menuItem);
                }
            });
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu() {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                });
            }, 0);
            
            return menu;
        }
        
        /**
         * Position context menu at coordinates
         * @param {HTMLElement} menu - Menu element
         * @param {number} x - X coordinate
         * @param {number} y - Y coordinate
         */
        function positionContextMenu(menu, x, y) {
            document.body.appendChild(menu);
            
            // Adjust position if menu would go off screen
            const rect = menu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            if (x + rect.width > viewportWidth) {
                x = viewportWidth - rect.width - 10;
            }
            
            if (y + rect.height > viewportHeight) {
                y = viewportHeight - rect.height - 10;
            }
            
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
        }
        
        /**
         * Focus on category color input
         * @param {number} categoryIndex - Category index
         */
        function focusCategoryColor(categoryIndex) {
            const colorInput = document.querySelector(`input[type="color"][value="${categories[categoryIndex].color}"]`);
            if (colorInput) {
                colorInput.click();
            }
        }
        
        // ===== HELP SYSTEM =====
        
        /**
         * Initialize help system
         */
        function initializeHelpSystem() {
            console.log('Initializing help system...');
            
            // Create help content
            createHelpContent();
        }
        
        /**
         * Show help dialog
         */
        function showHelpDialog() {
            const helpDialog = document.createElement('div');
            helpDialog.className = 'help-dialog';
            helpDialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border: 2px solid #667eea;
                border-radius: 12px;
                padding: 25px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
                z-index: 10000;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            `;
            
            helpDialog.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0; color: #333;">Dashboard Help</h2>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;"
                            aria-label="Close help dialog"></button>
                </div>
                
                <div style="line-height: 1.6;">
                    <h3 style="color: #667eea; margin-top: 0;">Getting Started</h3>
                    <p>This dashboard helps you analyze Quality Assurance review results by comparing data across different functions, categories, and time periods.</p>
                    
                    <h3 style="color: #667eea;">Key Features</h3>
                    <ul>
                        <li><strong>Interactive Charts:</strong> Click and hover to explore data</li>
                        <li><strong>Customizable Layout:</strong> Adjust spacing, colors, and text styles</li>
                        <li><strong>Trend Analysis:</strong> View percentage trends across time periods</li>
                        <li><strong>Data Management:</strong> Add, edit, or remove functions and categories</li>
                        <li><strong>Export Options:</strong> Save charts, data, and reports</li>
                    </ul>
                    
                    <h3 style="color: #667eea;">Keyboard Shortcuts</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">
                        <div><kbd>Ctrl+Shift+E</kbd> Export Menu</div>
                        <div><kbd>Ctrl+Shift+I</kbd> Import Menu</div>
                        <div><kbd>Ctrl+E</kbd> Export Chart Image</div>
                        <div><kbd>Ctrl+M</kbd> Maximize Chart</div>
                        <div><kbd>Ctrl+S</kbd> Save Dashboard</div>
                        <div><kbd>Ctrl+Z</kbd> Restore Backup</div>
                        <div><kbd>Alt+1</kbd> Column Chart</div>
                        <div><kbd>Alt+2</kbd> Bar Chart</div>
                        <div><kbd>Alt+A</kbd> Toggle Animation</div>
                        <div><kbd>Alt+T</kbd> Toggle Trend Lines</div>
                        <div><kbd>F1</kbd> Show Help</div>
                        <div><kbd>F5</kbd> Refresh Charts</div>
                    </div>
                    
                    <h3 style="color: #667eea;">Tips & Tricks</h3>
                    <ul>
                        <li>Right-click on chart elements for context menus</li>
                        <li>Use the toolbar buttons for quick access to common actions</li>
                        <li>Click on function/category names to rename them</li>
                        <li>Hover over controls for helpful tooltips</li>
                        <li>The dashboard automatically saves backups every 5 minutes</li>
                    </ul>
                    
                    <h3 style="color: #667eea;">Accessibility</h3>
                    <p>This dashboard supports keyboard navigation, screen readers, and high contrast mode. Use Tab to navigate between controls and Shift+Tab to go backwards.</p>
                </div>
            `;
            
            // Add overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
            `;
            overlay.onclick = function() {
                document.body.removeChild(overlay);
                document.body.removeChild(helpDialog);
            };
            
            document.body.appendChild(overlay);
            document.body.appendChild(helpDialog);
            
            announceChange('Help dialog opened');
        }
        
        /**
         * Create help content for tooltips and guidance
         */
        function createHelpContent() {
            // Add helpful tooltips to various elements
            const tooltips = [
                { selector: '#chartType', text: 'Choose between vertical columns or horizontal bars' },
                { selector: '#animation', text: 'Enable smooth chart animations (disable for better performance)' },
                { selector: '#sortBy', text: 'Sort functions by name, totals, or performance metrics' },
                { selector: '#showTrendLine', text: 'Display percentage trend lines on secondary axis' },
                { selector: '#columnSpacing', text: 'Adjust space between year columns within each function' },
                { selector: '#categoryGap', text: 'Control gap between different function groups' }
            ];
            
            tooltips.forEach(({ selector, text }) => {
                const element = document.querySelector(selector);
                if (element && !element.title) {
                    element.title = text;
                }
            });
        }
        
        // ===== AUTO-SAVE FUNCTIONALITY =====
        
        /**
         * Setup automatic saving functionality
         */
        function setupAutoSave() {
            console.log('Setting up auto-save functionality...');
            
            // Save when data changes
            const originalHandleDataInput = handleDataInput;
            window.handleDataInput = function(...args) {
                const result = originalHandleDataInput.apply(this, args);
                triggerAutoSave();
                return result;
            };
            
            // Save when configuration changes
            ['addFunction', 'removeFunction', 'addCategory', 'removeCategory', 'addYear', 'removeYear'].forEach(funcName => {
                if (typeof window[funcName] === 'function') {
                    const originalFunc = window[funcName];
                    window[funcName] = function(...args) {
                        const result = originalFunc.apply(this, args);
                        triggerAutoSave();
                        return result;
                    };
                }
            });
        }
        
        /**
         * Trigger auto-save
         */
        function triggerAutoSave() {
            // Debounce auto-save to avoid excessive saves
            if (triggerAutoSave.timeout) {
                clearTimeout(triggerAutoSave.timeout);
            }
            
            triggerAutoSave.timeout = setTimeout(() => {
                createAutoBackup();
                markAsChanged();
                console.log('Auto-save triggered');
            }, 2000); // Save 2 seconds after last change
        }
        
        // ===== TOUR SYSTEM =====
        
        /**
         * Initialize dashboard tour system
         */
        function initializeTourSystem() {
            console.log('Initializing tour system...');
            
            // Create tour steps
            createTourSteps();
        }
        
        /**
         * Toggle dashboard tour
         */
        function toggleDashboardTour() {
            if (document.querySelector('.tour-overlay')) {
                endTour();
            } else {
                startTour();
            }
        }
        
        /**
         * Start guided tour
         */
        function startTour() {
            const tourSteps = [
                {
                    element: '.header',
                    title: 'Welcome to the QA Dashboard',
                    content: 'This dashboard helps you analyze Quality Assurance review results. Let\'s take a quick tour!'
                },
                {
                    element: '#chartContainer',
                    title: 'Main Chart',
                    content: 'This is your main chart showing QA results. You can interact with it, export it, or maximize it for better viewing.'
                },
                {
                    element: '.controls',
                    title: 'Chart Controls',
                    content: 'Use these controls to change chart type, sorting, and display options. Try different combinations!'
                },
                {
                    element: '.sidebar',
                    title: 'Configuration Panel',
                    content: 'The sidebar contains all configuration options. You can manage years, categories, functions, and styling here.'
                },
                {
                    element: '#dataInputContainer',
                    title: 'Data Entry',
                    content: 'Enter your QA review data here. Values automatically update the charts in real-time.'
                },
                {
                    element: '#main-toolbar',
                    title: 'Main Toolbar',
                    content: 'Quick access to export, import, help, and reset functions. You can also use keyboard shortcuts!'
                }
            ];
            
            showTourStep(0, tourSteps);
            announceChange('Dashboard tour started');
        }
        
        /**
         * Show a tour step
         * @param {number} stepIndex - Current step index
         * @param {Array} steps - Array of tour steps
         */
        function showTourStep(stepIndex, steps) {
            if (stepIndex >= steps.length) {
                endTour();
                return;
            }
            
            const step = steps[stepIndex];
            const targetElement = document.querySelector(step.element);
    </script>
</head>
<body>
    <!-- Skip navigation link for accessibility - allows keyboard users to jump to main content -->
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <!-- Main container wrapper for the entire dashboard -->
    <div class="container" id="mainContainer">
        
        <!-- Header section with title and description -->
        <header class="header">
            <h1>Enhanced QA Review Analytics Dashboard</h1>
            <p>Fully Customizable Review Analysis with Advanced Styling & Export Options</p>
        </header>
        
        <!-- Main dashboard grid layout container -->
        <div class="dashboard" id="dashboardGrid">
            
            <!-- Main content area containing charts and controls -->
            <main id="main-content" class="main-content">
                
                <!-- Top control bar for basic chart settings -->
                <section class="controls" role="region" aria-label="Chart Controls" tabindex="0">
                    
                    <!-- Chart type selection -->
                    <div class="control-group">
                        <label for="chartType">Chart Type</label>
                        <select id="chartType" aria-describedby="chartType-help">
                            <option value="bar">Stacked Column</option>
                            <option value="horizontalBar">Stacked Bar</option>
                        </select>
                        <div id="chartType-help" class="sr-only">Choose between vertical or horizontal stacked chart display</div>
                    </div>
                    
                    <!-- Animation toggle -->
                    <div class="control-group">
                        <label for="animation">Animation</label>
                        <select id="animation" aria-describedby="animation-help">
                            <option value="true">Enabled</option>
                            <option value="false">Disabled</option>
                        </select>
                        <div id="animation-help" class="sr-only">Enable or disable chart animations for better accessibility</div>
                    </div>
                    
                    <!-- Sorting options -->
                    <div class="control-group">
                        <label for="sortBy">Sort By</label>
                        <select id="sortBy" aria-describedby="sortBy-help">
                            <option value="default">Default Order</option>
                            <option value="name">Function Name</option>
                            <option value="totalPrevious">Previous Year Total</option>
                            <option value="totalCurrent">Current Year Total</option>
                            <option value="improvement">Improvement Rate</option>
                            <option value="passRateCurrent">Current Year Pass Rate</option>
                        </select>
                        <div id="sortBy-help" class="sr-only">Choose how to sort functions in the chart</div>
                    </div>
                    
                    <!-- Sort direction -->
                    <div class="control-group">
                        <label for="sortDirection">Sort Direction</label>
                        <select id="sortDirection" aria-describedby="sortDirection-help">
                            <option value="asc">Ascending</option>
                            <option value="desc">Descending</option>
                        </select>
                        <div id="sortDirection-help" class="sr-only">Choose ascending or descending sort order</div>
                    </div>
                    
                    <!-- Quick function addition -->
                    <div class="control-group">
                        <label for="newFunctionName">Add Function</label>
                        <input type="text" id="newFunctionName" placeholder="Function name" aria-describedby="newFunction-help">
                        <div id="newFunction-help" class="sr-only">Enter a new function name to add to the analysis</div>
                    </div>
                    
                    <!-- Add function button -->
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="addFunction()" aria-describedby="addFunction-help">Add Function</button>
                        <div id="addFunction-help" class="sr-only">Click to add the new function to the dashboard</div>
                    </div>
                    
                    <!-- Chart view controls -->
                    <div class="control-group">
                        <label for="maximizeChart">Chart View</label>
                        <button id="maximizeChart" onclick="toggleChartMaximize()" aria-describedby="maximize-help">
                            Maximize Chart
                        </button>
                        <div id="maximize-help" class="sr-only">Expand chart to full viewport size</div>
                    </div>
                    
                    <!-- Export functionality -->
                    <div class="control-group">
                        <label for="exportChart">Export</label>
                        <button id="exportChart" onclick="exportChartImage()" aria-describedby="export-help">
                            Take Snapshot
                        </button>
                        <div id="export-help" class="sr-only">Capture chart as image and store in memory</div>
                    </div>
                </section>
                
                <!-- Main chart container with maximize overlay capability -->
                <section class="chart-container" id="chartContainer" role="region" aria-label="Main Chart" tabindex="0">
                    <!-- Chart maximize overlay (hidden by default) -->
                    <div class="chart-maximize-overlay" id="chartMaximizeOverlay" style="display: none;">
                        <div class="maximize-header">
                            <h3>Chart Maximized View</h3>
                            <button class="close-maximize" onclick="toggleChartMaximize()" aria-label="Close maximized view"></button>
                        </div>
                        <div class="maximize-chart-wrapper">
                            <canvas id="qaChartMaximized" role="img" aria-label="Maximized Quality Assurance Review Results Chart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Regular chart canvas -->
                    <canvas id="qaChart" role="img" aria-label="Quality Assurance Review Results Chart"></canvas>
                    
                    <!-- Custom legend container -->
                    <div class="legend-custom" id="legendContainer" role="list" aria-label="Chart Legend"></div>
                </section>
                
                <!-- Data input form section -->
                <section class="data-input" id="dataInputContainer" role="region" aria-label="Data Input Form" tabindex="0"></section>
            </main>
            
            <!-- Sidebar for configuration options -->
            <aside class="sidebar" role="complementary" aria-label="Configuration Panel">
                
                <!-- Years management section -->
                <div class="section-header">Years Configuration</div>
                <div class="add-item">
                    <input type="text" id="newYearName" placeholder="Year (e.g., 2023)" aria-label="New Year Name">
                    <select id="yearType" aria-label="Year Type">
                        <option value="previous">Previous</option>
                        <option value="current">Current</option>
                    </select>
                    <button onclick="addYear()">Add Year</button>
                </div>
                <div id="yearsList" role="list" aria-label="Years List"></div>
                
                <!-- Axis controls section -->
                <div class="section-header">Axis Controls</div>
                <div class="axis-controls">
                    <!-- Primary Y-axis (Accounts) controls -->
                    <div class="axis-section">
                        <h4>Primary Axis (Number of Accounts)</h4>
                        <div class="axis-control-group">
                            <div class="axis-control">
                                <label for="primaryAxisMin">Min Value</label>
                                <input type="number" id="primaryAxisMin" placeholder="Auto" aria-label="Primary axis minimum value">
                                <div class="checkbox-item">
                                    <input type="checkbox" id="primaryAxisAutoMin" checked>
                                    <label for="primaryAxisAutoMin">Auto</label>
                                </div>
                            </div>
                            <div class="axis-control">
                                <label for="primaryAxisMax">Max Value</label>
                                <input type="number" id="primaryAxisMax" placeholder="Auto" aria-label="Primary axis maximum value">
                                <div class="checkbox-item">
                                    <input type="checkbox" id="primaryAxisAutoMax" checked>
                                    <label for="primaryAxisAutoMax">Auto</label>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Secondary Y-axis (Percentage) controls -->
                    <div class="axis-section">
                        <h4>Secondary Axis (Percentage %)</h4>
                        <div class="axis-control-group">
                            <div class="axis-control">
                                <label for="secondaryAxisMin">Min Value</label>
                                <input type="number" id="secondaryAxisMin" value="0" min="0" max="100" aria-label="Secondary axis minimum value">
                                <div class="checkbox-item">
                                    <input type="checkbox" id="secondaryAxisAutoMin">
                                    <label for="secondaryAxisAutoMin">Auto</label>
                                </div>
                            </div>
                            <div class="axis-control">
                                <label for="secondaryAxisMax">Max Value</label>
                                <input type="number" id="secondaryAxisMax" value="100" min="0" max="100" aria-label="Secondary axis maximum value">
                                <div class="checkbox-item">
                                    <input type="checkbox" id="secondaryAxisAutoMax">
                                    <label for="secondaryAxisAutoMax">Auto</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Chart spacing controls -->
                <div class="section-header">Chart Spacing</div>
                <div class="spacing-controls">
                    <div class="spacing-control">
                        <label for="columnSpacing">Column Spacing: <span class="value-display" id="columnSpacingValue">1</span></label>
                        <input type="range" id="columnSpacing" min="0" max="5" value="1" aria-describedby="columnSpacing-help">
                        <div id="columnSpacing-help" class="spacing-description">Adjust space between year columns within each function</div>
                    </div>
                    <div class="spacing-control">
                        <label for="categoryGap">Category Gap: <span class="value-display" id="categoryGapValue">3</span></label>
                        <input type="range" id="categoryGap" min="1" max="8" value="3" aria-describedby="categoryGap-help">
                        <div id="categoryGap-help" class="spacing-description">Adjust gap between different function categories</div>
                    </div>
                </div>
                
                <!-- Text styling section -->
                <div class="section-header">Text Styling</div>
                <div class="text-styling-controls">
                    <!-- Data labels text styling -->
                    <div class="text-style-group">
                        <h4>Data Labels</h4>
                        <div class="style-controls">
                            <div class="style-control">
                                <label for="dataLabelFontSize">Font Size: <span id="dataLabelFontSizeValue">11px</span></label>
                                <input type="range" id="dataLabelFontSize" min="8" max="20" value="11">
                            </div>
                            <div class="style-control">
                                <label for="dataLabelColor">Color:</label>
                                <input type="color" id="dataLabelColor" value="#333333">
                            </div>
                            <div class="style-control">
                                <label for="dataLabelWeight">Font Weight:</label>
                                <select id="dataLabelWeight">
                                    <option value="normal">Normal</option>
                                    <option value="bold" selected>Bold</option>
                                    <option value="lighter">Light</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Axis labels text styling -->
                    <div class="text-style-group">
                        <h4>Axis Labels</h4>
                        <div class="style-controls">
                            <div class="style-control">
                                <label for="axisLabelFontSize">Font Size: <span id="axisLabelFontSizeValue">12px</span></label>
                                <input type="range" id="axisLabelFontSize" min="8" max="18" value="12">
                            </div>
                            <div class="style-control">
                                <label for="axisLabelColor">Color:</label>
                                <input type="color" id="axisLabelColor" value="#666666">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Function names text styling -->
                    <div class="text-style-group">
                        <h4>Function Names</h4>
                        <div class="style-controls">
                            <div class="style-control">
                                <label for="functionNameFontSize">Font Size: <span id="functionNameFontSizeValue">14px</span></label>
                                <input type="range" id="functionNameFontSize" min="10" max="20" value="14">
                            </div>
                            <div class="style-control">
                                <label for="functionNameColor">Color:</label>
                                <input type="color" id="functionNameColor" value="#333333">
                            </div>
                            <div class="style-control">
                                <label for="functionNameWeight">Font Weight:</label>
                                <select id="functionNameWeight">
                                    <option value="normal">Normal</option>
                                    <option value="bold" selected>Bold</option>
                                    <option value="lighter">Light</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Category labels text styling -->
                    <div class="text-style-group">
                        <h4>Category Labels</h4>
                        <div class="style-controls">
                            <div class="style-control">
                                <label for="categoryLabelFontSize">Font Size: <span id="categoryLabelFontSizeValue">12px</span></label>
                                <input type="range" id="categoryLabelFontSize" min="8" max="18" value="12">
                            </div>
                            <div class="style-control">
                                <label for="categoryLabelColor">Color:</label>
                                <input type="color" id="categoryLabelColor" value="#333333">
                            </div>
                            <div class="style-control">
                                <label for="categoryLabelWeight">Font Weight:</label>
                                <select id="categoryLabelWeight">
                                    <option value="normal" selected>Normal</option>
                                    <option value="bold">Bold</option>
                                    <option value="lighter">Light</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Data labels display options -->
                <div class="section-header">Data Labels</div>
                <div class="data-labels-section">
                    <div class="checkbox-item">
                        <input type="checkbox" id="showDataLabels" checked>
                        <label for="showDataLabels">Show Data Labels</label>
                    </div>
                    <div class="checkbox-group" id="dataLabelOptions">
                        <div class="checkbox-item">
                            <input type="checkbox" id="showValues" checked>
                            <label for="showValues">Values</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showPercentages">
                            <label for="showPercentages">Percentages</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="showTrendLine" checked>
                            <label for="showTrendLine">Trend Lines</label>
                        </div>
                    </div>
                </div>
                
                <!-- Trend line configuration -->
                <div class="section-header">Trend Line Configuration</div>
                <div class="trendline-controls" id="trendlineControls">
                    <!-- Dynamic trend line controls will be generated here -->
                </div>
                
                <!-- Shading options -->
                <div class="section-header">Shading Options</div>
                <div class="shading-controls">
                    <div class="shading-option">
                        <input type="radio" id="shadingAuto" name="shading" value="auto" checked>
                        <label for="shadingAuto">Auto (Previous=Light, Current=Dark)</label>
                    </div>
                    <div class="shading-option">
                        <input type="radio" id="shadingManual" name="shading" value="manual">
                        <label for="shadingManual">Manual Opacity Control</label>
                    </div>
                    <div id="manualOpacityControls" style="display: none;">
                        <label for="prevOpacity">Previous Year Opacity: <span id="prevOpacityValue">50%</span></label>
                        <input type="range" id="prevOpacity" min="10" max="100" value="50" style="width: 100%;" aria-describedby="prevOpacity-help">
                        <div id="prevOpacity-help" class="sr-only">Adjust opacity for previous year data from 10% to 100%</div>
                        <label for="currOpacity">Current Year Opacity: <span id="currOpacityValue">100%</span></label>
                        <input type="range" id="currOpacity" min="10" max="100" value="100" style="width: 100%;" aria-describedby="currOpacity-help">
                        <div id="currOpacity-help" class="sr-only">Adjust opacity for current year data from 10% to 100%</div>
                    </div>
                    <div class="shading-preview">
                        <span>Preview:</span>
                        <div class="preview-box" id="prevPreview" style="background-color: #4CAF5080;" aria-label="Previous year color preview"></div>
                        <div class="preview-box" id="currPreview" style="background-color: #4CAF50;" aria-label="Current year color preview"></div>
                    </div>
                </div>
                
                <!-- Categories management -->
                <div class="section-header">Categories</div>
                <div class="add-item">
                    <input type="text" id="newCategoryName" placeholder="Category name" aria-label="New Category Name">
                    <input type="color" id="newCategoryColor" value="#2196F3" aria-label="Category Color">
                    <button onclick="addCategory()">Add Category</button>
                </div>
                <div id="categoriesList" role="list" aria-label="Categories List"></div>
                
                <!-- Functions management -->
                <div class="section-header">Functions</div>
                <div class="sorting-controls" id="functionsList" role="list" aria-label="Functions List"></div>
            </aside>
        </div>
    </div>
    
    <!-- Hidden elements for accessibility announcements -->
    <div id="announcement" class="sr-only" aria-live="polite" aria-atomic="true"></div>
    
    <!-- Image storage container for exported charts -->
    <div id="imageStorage" style="display: none;" aria-hidden="true"></div>
</body>
</html>
